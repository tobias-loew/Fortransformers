%token SEOS 1
%token SCOMMENT 2
%token SLABEL 3
%token SUNKNOWN 4
%token SHOLLERITH 5
%token SICON 6
%token SRCON 7
%token SDCON 8
%token SBITCON 9
%token SOCTCON 10
%token SHEXCON 11
%token STRUE 12
%token SFALSE 13
%token SNAME 14
%token SNAMEEQ 15
%token SFIELD 16
%token SSCALE 17
%token SINCLUDE 18
%token SLET 19
%token SASSIGN 20
%token SAUTOMATIC 21
%token SBACKSPACE 22
%token SBLOCK 23
%token SCALL 24
%token SCHARACTER 25
%token SCLOSE 26
%token SCOMMON 27
%token SCOMPLEX 28
%token SCONTINUE 29
%token SDATA 30
%token SDCOMPLEX 31
%token SDIMENSION 32
%token SDO 33
%token SDOUBLE 34
%token SELSE 35
%token SELSEIF 36
%token SEND 37
%token SENDFILE 38
%token SENDIF 39
%token SENTRY 40
%token SEQUIV 41
%token SEXTERNAL 42
%token SFORMAT 43
%token SFUNCTION 44
%token SGOTO 45
%token SASGOTO 46
%token SCOMPGOTO 47
%token SARITHIF 48
%token SLOGIF 49
%token SIMPLICIT 50
%token SINQUIRE 51
%token SINTEGER 52
%token SINTRINSIC 53
%token SLOGICAL 54
%token SNAMELIST 55
%token SOPEN 56
%token SPARAM 57
%token SPAUSE 58
%token SPRINT 59
%token SPROGRAM 60
%token SPUNCH 61
%token SREAD 62
%token SREAL 63
%token SRETURN 64
%token SREWIND 65
%token SSAVE 66
%token SSTATIC 67
%token SSTOP 68
%token SSUBROUTINE 69
%token STHEN 70
%token STO 71
%token SUNDEFINED 72
%token SWRITE 73
%token SLPAR 74
%token SRPAR 75
%token SEQUALS 76
%token SCOLON 77
%token SCOMMA 78
%token SCURRENCY 79
%token SPLUS 80
%token SMINUS 81
%token SSTAR 82
%token SSLASH 83
%token SPOWER 84
%token SCONCAT 85
%token SAND 86
%token SOR 87
%token SNEQV 88
%token SEQV 89
%token SNOT 90
%token SEQ 91
%token SLT 92
%token SGT 93
%token SLE 94
%token SGE 95
%token SNE 96
%token SENDDO 97
%token SWHILE 98
%token SSLASHD 99
%token SSELECT 100
%token SCASE 101
%token SCASEDEFAULT 102
%token SENDSELECT 103
%token SINTENT 104
%token SIN 105
%token SOUT 106
%token SINOUT 107
%token SVALUE 108
%token SLPARSLASH 109
%token SSLASHRPAR 110
%token SMODULE 111
%token SCONTAINS 112
%token SPURE 113
%token SELEMENTAL 114
%token SBIND 115
%token STYPE 116
%token SUSE 117
%token SENDFUNCTION 118
%token SENDSUBROUTINE 119
%token SENDMODULE 120
%token SENDPROGRAM 121
%token SENDTYPE 122
%token SMEMBER 123
%token SCYCLE 124
%token SEXIT 125
%token SPRIVATE 126
%token SPUBLIC 127
%token SDOCONCURRENT 128
%token SORDER 129
%token SRESHAPE 130
%token SINTERFACE 131
%token SENDINTERFACE 132
%token SALLOCATABLE 133
%token SALLOCATE 134
%token SSOURCE 135
%token SSTAT 136
%token SDOT 137
%token SOPTIONAL 138
%token SPOINTER 139
%token SDEALLOCATE 140
%token SCLASS 141
%token SEXTENDS 142
%token SKIND 143
%token SRESULT 144
%token SLEN 145
%token	SC_INT	146
%token	SC_SHORT	147
%token	SC_LONG	148
%token	SC_LONG_LONG	149
%token	SC_SIGNED_CHAR	150
%token	SC_SIZE_T	151
%token	SC_INT8_T	152
%token	SC_INT16_T	153
%token	SC_INT32_T	154
%token	SC_INT64_T	155
%token	SC_INT128_T	156
%token	SC_INT_LEAST8_T	157
%token	SC_INT_LEAST16_T	158
%token	SC_INT_LEAST32_T	159
%token	SC_INT_LEAST64_T	160
%token	SC_INT_LEAST128_T	161
%token	SC_INT_FAST8_T	162
%token	SC_INT_FAST16_T	163
%token	SC_INT_FAST32_T	164
%token	SC_INT_FAST64_T	165
%token	SC_INT_FAST128_T	166
%token	SC_INTMAX_T	167
%token	SC_INTPTR_T	168
%token	SC_PTRDIFF_T	169
%token	SC_FLOAT	170
%token	SC_DOUBLE	171
%token	SC_LONG_DOUBLE	172
%token	SC_FLOAT128	173
%token	SC_FLOAT_COMPLEX	174
%token	SC_DOUBLE_COMPLEX	175
%token	SC_LONG_DOUBLE_COMPLEX	176
%token	SC_FLOAT128_COMPLEX	177
%token	SC_BOOL	178
%token	SC_CHAR	179
%token	SINT64	180
%token	SREAL128	181
%token	SONLY	182

/****************************************************************
Copyright 1990, 1993 by AT&T Bell Laboratories, Bellcore.

Permission to use, copy, modify, and distribute this software
and its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the names of AT&T Bell Laboratories or
Bellcore or any of their entities not be used in advertising or
publicity pertaining to distribution of the software without
specific, written prior permission.

AT&T and Bellcore disclaim all warranties with regard to this
software, including all implied warranties of merchantability
and fitness.  In no event shall AT&T or Bellcore be liable for
any special, indirect or consequential damages or any damages
whatsoever resulting from loss of use, data or profits, whether
in an action of contract, negligence or other tortious action,
arising out of or in connection with the use or performance of
this software.
****************************************************************/

%{
#include <string>
#include "defs.h"
#include "func_def.h"
#include "p1defs.h"

static int nstars;			/* Number of labels in an
					   alternate return CALL */
static int datagripe;
int ndim;
int ndim_type;  // dimension for all variables of the type
static int vartype;
extern std::string var_derived_type_name;
extern std::string var_derived_type_extends_name;
int new_dcl;
static ftnint varleng;
struct Dims dims[MAXDIM+1];
struct Dims dims_type[MAXDIM+1];
bool in_dims_type = false;
extern struct Labelblock **labarray;	/* Labels in an alternate
						   return CALL */
extern int maxlablist;
extern bool in_member_access = false;
/* The next two variables are used to verify that each statement might be reached
   during runtime.   lastwasbranch   is tested only in the defintion of the
   stat:   nonterminal. */

int lastwasbranch = NO;
static int thiswasbranch = NO;
extern ftnint yystno;
extern flag intonly;
static chainp datastack;
extern long laststfcn, thisstno;
extern int can_include;	/* for netlib */

//ftnint convci();
//Addrp nextdata();
//expptr mklogcon(), mkaddcon(), mkrealcon(), mkstrcon(), mkbitcon();
//expptr mkcxcon();
//struct Listblock *mklist();
//struct Listblock *mklist();
//struct Impldoblock *mkiodo();
//Extsym *comblock();
#define ESNULL (Extsym *)0
#define NPNULL (Namep)0
#define LBNULL (struct Listblock *)0
//extern void freetemps(), make_param();


 static void
pop_datastack() {
	chainp d0 = datastack;
	if (d0->datap)
		curdtp = (chainp)d0->datap;
	datastack = d0->nextp;
	d0->nextp = 0;
	frchain(&d0);
	}

%}

/*  %glr-parser */

/* Specify precedences and associativities. */

%union	{
	int ival;
    ii_val_t ii_val;
	ftnint lval;
	char *charpval;
	chainp chval;
	tagptr tagval;
	expptr expval;
	struct Labelblock *labval;
	struct Nameblock *namval;
	struct Eqvchain *eqvval;
	Extsym *extval;
	}

%left SCOMMA
%nonassoc SCOLON
%right SEQUALS
%left SEQV SNEQV
%left SOR
%left SAND
%left SNOT
%nonassoc SLT SGT SLE SGE SEQ SNE
%left SCONCAT
%left SPLUS SMINUS
%left SSTAR SSLASH
%right SPOWER
//%left SMEMBER  SOPCALL
%left SOPCALL SLPAR SMEMBER SDOT

%start program
%type <labval> thislabel label assignlabel
%type <tagval> other inelt
%type <ival> type typespec typename letter addop relop stop nameeq attribute attributes inout
%type <ii_val> dcl
%type <ival> routine_prefix routine_prefixes routine_prefixes_opt
%type <lval> lengspec type_lengspec type_lengspec_name type_lengspec_helper type_lengspec_name_kwd
%type <charpval> filename
%type <chval> datavar datavarlist namelistlist funarglist funargs paraminits paraminit
%type <chval> dospec dospecw doconcspec wherespecs doconcloop doconcloops
%type <chval> callarglist arglist args exprlist inlist outlist out2 substring in_substring
%type <chval> routine_postfixes routine_postfixes_opt
%type <namval> routine_postfix
%type <namval> name arg call var
%type <expval> lengspec_or_dims lhs lhs_base expr uexpr opt_expr fexpr unpar_fexpr funarg
%type <expval> expr_member_access
%type <expval> ubound simple value callarg simple_const bit_const
/*  %type <expval> complex_const */
%type <expval> caseval
%type <extval> common comblock entryname progname
%type <eqvval> equivlist
%type <chval> caselist casedecl
%type <chval> casespec
%type <expval> opt_init_list
%type <expval> expr_do_list

%%

program:
	| program stat SEOS
	;

stat:	  thislabel  entry
		{
/* stat:   is the nonterminal for Fortran statements */

		  lastwasbranch = NO; }
	| thislabel  spec
	| thislabel  exec
		{ /* forbid further statement function definitions... */
		  if (parstate == INDATA && laststfcn != thisstno)
			parstate = INEXEC;
		  thisstno++;
		  if($1 && ($1->labelno==dorange))
			enddo($1->labelno, false, 1);
		  if(lastwasbranch && thislabel==NULL)
			warn("statement cannot be reached");
		  lastwasbranch = thiswasbranch;
		  thiswasbranch = NO;
		  if($1)
			{
			if($1->labtype == LABFORMAT)
				err("label already that of a format");
			else
				$1->labtype = LABEXEC;
			}
		  freetemps();
		}
	| thislabel SINCLUDE filename
		{ if (can_include)
			doinclude( $3, true );
		  else {
			fprintf(diagfile, "Cannot open file %s\n", $3);
			done(1);
			}
		}
	| thislabel  SEND /* end_spec */
		{ if ($1)
			lastwasbranch = NO;
		  endproc(); /* lastwasbranch = NO; -- set in endproc() */
		}
	| thislabel  SENDFUNCTION opt_name end_spec 
		{ if ($1)
			lastwasbranch = NO;
		  endproc(); /* lastwasbranch = NO; -- set in endproc() */
		}
	| thislabel  SENDSUBROUTINE opt_name end_spec 
		{ if ($1)
			lastwasbranch = NO;
		  endproc(); /* lastwasbranch = NO; -- set in endproc() */
		}
	| thislabel  SENDPROGRAM opt_name end_spec
		{ if ($1)
			lastwasbranch = NO;
		  endproc(); /* lastwasbranch = NO; -- set in endproc() */
		}
	| thislabel   SENDMODULE opt_name /* end_spec */
		{  
        exendmodule();
       // if ($1)
		//	lastwasbranch = NO;
       //     endproc(); /* lastwasbranch = NO; -- set in endproc() */
		}
	| thislabel  SENDTYPE opt_name /* end_spec */
		{ 
         if ($1)
			lastwasbranch = NO;
            endtype(); /* lastwasbranch = NO; -- set in endproc() */

        //enddcl(); endproc(); 
		}
	| thislabel  SENDINTERFACE
      { in_interface_definition = false;}
	| thislabel SUNKNOWN
		{ extern void unclassifiable();
		  unclassifiable();

/* flline flushes the current line, ignoring the rest of the text there */

		  flline(); };
	| error
		{ flline();  needkwd = NO;  inioctl = NO;
		  yyerrok; yyclearin; }
	;

thislabel:  SLABEL
		{
		if(yystno != 0)
			{
			$$ = thislabel =  mklabel(yystno);
			if( ! headerdone ) {
				if (procclass == CLUNKNOWN)
					procclass = CLMAIN;
				puthead(CNULL, procclass);
				}
			if(thislabel->labdefined)
				execerr("label %s already defined",
					convic(thislabel->stateno) );
			else	{
				if(thislabel->blklevel!=0 && thislabel->blklevel<(unsigned int)blklevel
				    && thislabel->labtype!=LABFORMAT)
					warn1("there is a branch to label %s from outside block",
					      convic( (ftnint) (thislabel->stateno) ) );
				thislabel->blklevel = blklevel;
				thislabel->labdefined = YES;
				if(thislabel->labtype != LABFORMAT)
					p1_label((long)(thislabel - labeltab));
				}
			}
		else    $$ = thislabel = NULL;
		}
	;

entry:	  SPROGRAM new_proc progname
		   {startproc($3, CLMAIN); }
	| SPROGRAM new_proc progname progarglist
		   {	warn("ignoring arguments to main program");
			/* hashclear(); */
			startproc($3, CLMAIN); }
	| SBLOCK new_proc progname
		{ if($3) NO66("named BLOCKDATA");
		  startproc($3, CLBLOCK); }
	| routine_prefixes_opt SSUBROUTINE new_proc entryname arglist { needkwd = 1; /*&&*/} routine_postfixes_opt {needkwd = 0;}
		{ entrypt(CLPROC, TYSUBR | $1, (ftnint) 0,  $4, $5, $7); }
/*
	| SFUNCTION new_proc entryname arglist
		{ entrypt(CLPROC, TYUNKNOWN, (ftnint) 0, $3, $4); }
*/
	| routine_prefixes_opt SFUNCTION new_proc entryname arglist { needkwd = 1; /*&&*/} routine_postfixes_opt {needkwd = 0;}
		{ entrypt(CLPROC, $1, varleng, $4, $5, $7); }
	| SENTRY entryname arglist
		 { if(parstate==OUTSIDE || procclass==CLMAIN
			|| procclass==CLBLOCK)
				execerr("misplaced entry statement", CNULL);
		  entrypt(CLENTRY, 0, (ftnint) 0, $2, $3, 0);
		}
    | SMODULE new_module SNAME
        { exmodule(token); }
        
    | SCONTAINS
        {enddcl(); endproc(); excontains(); }
        
    |
     SINTERFACE
      { /*assert(false);*/ in_interface_definition = true;}
	;


//opt_bind : {needkwd=0;}/*empty*/
//    |
//    SBIND SLPAR SNAME SRPAR


routine_postfix : 
            { needkwd = 1; } SBIND { needkwd = 0; } SLPAR SNAME SRPAR {needkwd = 1; $$ = 0;}
            | 
            { needkwd = 1; } SRESULT { needkwd = 0; } SLPAR name SRPAR {needkwd = 1; $$ = $5;}

routine_postfixes : { needkwd = 1; } routine_postfix
		{ $$ = ($2 ? mkchain((char *)$2,CHNULL) : CHNULL ); }
            | routine_postfixes { needkwd = 1; } routine_postfix
		{ if($3) /*$1 =*/ $$ = mkchain((char *)$3, $1); }

routine_postfixes_opt : /*empty*/
            {$$ = 0;}
            | routine_postfixes 
            {$$ = $1;}



routine_prefix : 
            type {$$=$1;}
            | 
            { needkwd = 1; } SELEMENTAL 
            {$$=TY_PREFIX_ELEMENTAL;}
            |
            { needkwd = 1; } SPURE
             {$$=TY_PREFIX_PURE;}

routine_prefixes : routine_prefix
            {$$ = $1;}
            | routine_prefixes routine_prefix
            {$$ = $1 | $2;}

routine_prefixes_opt : /*empty*/
            {needkwd = 0; $$ = TYUNKNOWN;}
            | routine_prefixes 
            {$$ = $1;}

new_proc:
		{ newproc(); }
	;

new_module:
		{ newmodule(); }
	;

entryname:  name
		{ $$ = newentry($1, 1); }
	;

opt_name:  
        |
        SNAME
	;

name:	  SNAME
		{ $$ = mkname(token); }
	;

progname:		{ $$ = NULL; }
	| entryname
	;

progarglist:
	  SLPAR SRPAR
	| SLPAR progargs SRPAR
	;

progargs: progarg
	| progargs SCOMMA progarg
	;

progarg:  SNAME
	| SNAME SEQUALS SNAME
	;

arglist:
		{ $$ = 0; }
	| SLPAR SRPAR
		{ NO66(" () argument list");
		  $$ = 0; }
	| SLPAR args SRPAR
		{$$ = $2; }
	;

args:	  arg
		{ $$ = ($1 ? mkchain((char *)$1,CHNULL) : CHNULL ); }
	| args SCOMMA arg
		{ if($3) /*$1 =*/ $$ = mkchain((char *)$3, $1); }
	;

arg:	  name
		{ if(!in_interface_definition){
              if($1->vstg!=STGUNKNOWN && $1->vstg!=STGARG)
			      dclerr("name declared as argument after use", $1);
		      $1->vstg = STGARG;
          }
		}
	| SSTAR
		{ NO66("altenate return argument");

/* substars   means that '*'ed formal parameters should be replaced.
   This is used to specify alternate return labels; in theory, only
   parameter slots which have '*' should accept the statement labels.
   This compiler chooses to ignore the '*'s in the formal declaration, and
   always return the proper value anyway.

   This variable is only referred to in   proc.c   */

		  $$ = 0;  substars = YES; }
	;



filename:   SHOLLERITH
		{
		char *s;
		s = copyn(toklen+1, token);
		s[toklen] = '\0';
		$$ = s;
		}
	;
spec:	  dcl { /* reset type global dimension */ ndim_type = 0; } 
	| common
	| external
	| intrinsic
	| equivalence
	| data
    | use
	| implicit
	| namelist
    | SPRIVATE
    | SPRIVATE SNAME
    | SPUBLIC
    | SPUBLIC SNAME
	| SSAVE
		{ NO66("SAVE statement");
		  saveall = YES; }
	| SSAVE savelist
		{ NO66("SAVE statement"); }
	| SFORMAT
		{ fmtstmt(thislabel); setfmt(thislabel); }
	| SPARAM in_dcl SLPAR paramlist SRPAR
		{ NO66("PARAMETER statement"); }
	;

dcl:	  type name in_dcl new_dcl dims lengspec_or_dims
		{ 
          if(!in_interface_definition){
              settype($2, $1, $6, 0);
		      if(ndim>0) {
                setbound($2,ndim,dims, $6);
              } else if(ndim_type>0) {
                setbound($2,ndim_type,dims_type, $6);
              }
          }
		}
    |	  type SCOLON SCOLON name in_dcl new_dcl dims lengspec_or_dims opt_init_list
		{ 
          if(!in_interface_definition){
              settype($4, $1, $8, 0);
		      if(ndim>0) {
                setbound($4,ndim,dims, $8);
              } else if(ndim_type>0) {
                setbound($4,ndim_type,dims_type, $8);
              }
              if($9)
                {
                          make_param((Paramblock *)$4, 0, $9);
                }
            }
		}
    | type SCOMMA { ndim_type = 0; needkwd = 1; }  attributes  SCOLON SCOLON name in_dcl new_dcl dims lengspec_or_dims opt_init_list
		{ 
          if(!in_interface_definition){
              $$.first = $1;
              $$.second = $4;
              settype($7, $1, $11, $4);
		      if(ndim>0) {
                setbound($7,ndim,dims, $11);
              } else if(ndim_type>0) {
                setbound($7,ndim_type,dims_type, $11);
              }
              if(/*($4 & ATTRIBUTE_PARAMETER) &&*/ $12)
                {
                          make_param((Paramblock *)$7, $4, $12);
                }
                else if(($4 & ATTRIBUTE_PARAMETER) /*|| $12*/)
                {
			        err("parameter requires initialization2");
                }
              if($4 & ATTRIBUTE_SAVE)
                {
		            $7->vsave = YES;
                }
            }
		}
    | STYPE SNAME 
    {newtype(token);}
    | STYPE opt_type_attrs SCOLON SCOLON SNAME 
    {newtype(token);}
	| dcl SCOMMA name dims lengspec_or_dims opt_init_list
		{ 
          if(!in_interface_definition){
              $$ = $1;
              settype2($3, $1, $5);
		      if(ndim>0) {
                setbound($3,ndim,dims, $5);
              } else if(ndim_type>0) {
                setbound($3,ndim_type,dims_type, $5);
              }
              if(/*($1.second & ATTRIBUTE_PARAMETER) &&*/ $6)
                {
                          make_param((Paramblock *)$3, $1.second, $6);
                }
                else if(($1.second & ATTRIBUTE_PARAMETER) /*|| $6*/)
                {
			        err("parameter requires initialization1");
                }
              if($1.second & ATTRIBUTE_SAVE)
                {
		            $3->vsave = YES;
                }
            }
		}
	| dcl SSLASHD datainit vallist SSLASHD
		{
          if(!in_interface_definition){
             if (new_dcl == 2) {
			    err("attempt to give DATA in type-declaration");
			    new_dcl = 1;
			    }
            }
		}
	;

type_attr:
    SBIND SLPAR SNAME SRPAR
    |
    SEXTENDS SLPAR SNAME SRPAR
        {var_derived_type_extends_name = token;}

type_attrs:
         SCOMMA {needkwd=1;} type_attr
    |
    type_attrs SCOMMA {needkwd=1;} type_attr

opt_type_attrs:
         {needkwd=0;}/*empty*/
    |
    type_attrs

opt_init_list:
        /*empty*/
        {$$= 0;}
//    | SEQUALS SLPARSLASH {needwkey_if_seen_type_dcolon=1;} opt_type paraminits SSLASHRPAR
//        {$$ = $5;}

    | SEQUALS expr
        {$$ = $2;}
    | SEQUALS SRESHAPE SLPAR expr SCOMMA const_array SCOMMA {needkwd  =  1;} SORDER SEQUALS const_array SRPAR
		{ 
         $$ = call1(TYUNKNOWN, "ft::transpose", $4);
        }


inout: SIN {$$= ATTRIBUTE_IN;}
    | SOUT {$$= ATTRIBUTE_OUT;}
    | SINOUT {$$= ATTRIBUTE_INOUT;}


attribute: 
        SINTENT  SLPAR { needkwd = 1; } inout SRPAR 
        {
           $$ = $4;
        }
        |
        SVALUE
        {
           $$ = ATTRIBUTE_VALUE;
        }
        |
        SPARAM
        {
           $$ = ATTRIBUTE_PARAMETER;
        }
        |
        SSAVE
        {
           $$ = ATTRIBUTE_SAVE;
        }
        |
        SPRIVATE
        {
           $$ = ATTRIBUTE_PRIVATE;
        }
        |
        SPUBLIC
        {
           $$ = ATTRIBUTE_PUBLIC;
        }
        |
        SALLOCATABLE
        {
           $$ = ATTRIBUTE_ALLOCATABLE;
        }
        |
        SOPTIONAL
        {
           $$ = ATTRIBUTE_OPTIONAL;
        }
        |
        SEXTERNAL
        {
           $$ = ATTRIBUTE_EXTERNAL;
        }
        |
        SDIMENSION  dims_type
        {
           $$ = 0;
        }
        ;


attributes: 
        { needkwd = 1; }  attribute
         {
           $$ = $2;
        }
       |
        attributes SCOMMA { needkwd = 1; }  attribute
        {
           $$ = $1 | $4;
        }
        ;


new_dcl:	{ new_dcl = 2; }

type:	  typespec type_lengspec
		{ varleng = $2; }
	;

typespec:  typename
		{ varleng = ($1<0 || ONEOF($1,M(TYLOGICAL)|M(TYLONG))
				? 0 : typesize[$1]);
		  vartype = $1; }
	;

typename:    SINTEGER	{ $$ = TYLONG; }
	| SREAL		{ $$ = tyreal; }
	| SCOMPLEX	{ ++complex_seen; $$ = tycomplex; }
	| SDOUBLE	{ $$ = TYDREAL; /*dp*/ }
	| SDCOMPLEX	{ ++dcomplex_seen; NOEXT("DOUBLE COMPLEX statement"); $$ = TYDCOMPLEX; }
	| SLOGICAL	{ $$ = TYLOGICAL; }
	| SCHARACTER	{ NO66("CHARACTER statement"); $$ = TYCHAR; }
	| SUNDEFINED	{ $$ = TYUNKNOWN; }
	| SDIMENSION	{ $$ = TYUNKNOWN; }
	| SAUTOMATIC	{ NOEXT("AUTOMATIC statement"); $$ = - STGAUTO; }
	| SSTATIC	{ NOEXT("STATIC statement"); $$ = - STGBSS; }
	| STYPE SLPAR SNAME SRPAR	{ $$ = TY_DERIVED; var_derived_type_name = token;}  
	| SCLASS SLPAR SNAME SRPAR	{ $$ = TY_DERIVED; var_derived_type_name = token;}  
	;

type_lengspec:
    lengspec {$$ = $1;}
    |
    SLPAR {trykwd=1;} type_lengspec_helper { $$ = $3;} 
//    |
//    SLPAR {trykwd=1;} intonlyon expr intonlyoff SRPAR {$$ = $4->constblock.Const.ci;}
//    |
//	SLPAR {trykwd=1;} type_lengspec_name SRPAR	{ $$ = $3;}   
    ;

type_lengspec_helper:
    intonlyon expr intonlyoff type_lengspec_opt_kind SRPAR {$$ = $2->constblock.Const.ci;}
    |
	type_lengspec_name SRPAR	{ $$ = $1;}   
    ;

type_lengspec_name_kwd:
        SC_BOOL                         { $$ = length_from_name("c_bool");}  
      | SC_CHAR                         { $$ = length_from_name("c_char");}  
      | SC_DOUBLE                       { $$ = length_from_name("c_double");}  
      | SC_DOUBLE_COMPLEX               { $$ = length_from_name("c_double_complex");}  
      | SC_FLOAT                        { $$ = length_from_name("c_float");}  
      | SC_FLOAT_COMPLEX                { $$ = length_from_name("c_float_complex");}  
      | SC_FLOAT128                     { $$ = length_from_name("c_float128");}  
      | SC_FLOAT128_COMPLEX             { $$ = length_from_name("c_float128_complex");}  
      | SC_INT                          { $$ = length_from_name("c_int");}  
      | SC_INT_FAST128_T                { $$ = length_from_name("c_int_fast128_t");}  
      | SC_INT_FAST16_T                 { $$ = length_from_name("c_int_fast16_t");}  
      | SC_INT_FAST32_T                 { $$ = length_from_name("c_int_fast32_t");}  
      | SC_INT_FAST64_T                 { $$ = length_from_name("c_int_fast64_t");}  
      | SC_INT_FAST8_T                  { $$ = length_from_name("c_int_fast8_t");}  
      | SC_INT_LEAST128_T               { $$ = length_from_name("c_int_least128_t");}  
      | SC_INT_LEAST16_T                { $$ = length_from_name("c_int_least16_t");}  
      | SC_INT_LEAST32_T                { $$ = length_from_name("c_int_least32_t");}  
      | SC_INT_LEAST64_T                { $$ = length_from_name("c_int_least64_t");}  
      | SC_INT_LEAST8_T                 { $$ = length_from_name("c_int_least8_t");}  
      | SC_INT128_T                     { $$ = length_from_name("c_int128_t");}  
      | SC_INT16_T                      { $$ = length_from_name("c_int16_t");}  
      | SC_INT32_T                      { $$ = length_from_name("c_int32_t");}  
      | SC_INT64_T                      { $$ = length_from_name("c_int64_t");}  
      | SC_INT8_T                       { $$ = length_from_name("c_int8_t");}  
      | SC_INTMAX_T                     { $$ = length_from_name("c_intmax_t");}  
      | SC_INTPTR_T                     { $$ = length_from_name("c_intptr_t");}  
      | SC_LONG                         { $$ = length_from_name("c_long");}  
      | SC_LONG_DOUBLE                  { $$ = length_from_name("c_long_double");}  
      | SC_LONG_DOUBLE_COMPLEX          { $$ = length_from_name("c_long_double_complex");}  
      | SC_LONG_LONG                    { $$ = length_from_name("c_long_long");}  
      | SC_PTRDIFF_T                    { $$ = length_from_name("c_ptrdiff_t");}  
      | SC_SHORT                        { $$ = length_from_name("c_short");}  
      | SC_SIGNED_CHAR                  { $$ = length_from_name("c_signed_char");}  
      | SC_SIZE_T                       { $$ = length_from_name("c_size_t");}  
      | SINT64                          { $$ = length_from_name("int64");}  
      | SREAL128                        { $$ = length_from_name("real128");}  


//name_as_string : 
//    SNAME {$$ = strdup(token);}
    ;

type_lengspec_name:
    type_lengspec_name_kwd { $$ = $1;}   
    |
	SKIND SEQUALS {trykwd=1; /* jdslgjks*/} type_lengspec_name_kwd type_lengspec_opt_len  { $$ = $4;}   
    |
    // "len" only used with characters -> len and kind ignored (set to 1)
	SLEN SEQUALS intonlyon expr intonlyoff type_lengspec_opt_kind { $$ = 1;}
    ;

type_lengspec_opt_len:
    /* empty */
    |
    SCOMMA {trykwd=1;}  SLEN SEQUALS expr
    ;

type_lengspec_opt_kind:
    /* empty */
    |
    SCOMMA {trykwd=1;}  type_lengspec_opt_kind_helper
    ;

type_lengspec_opt_kind_helper:
    SKIND SEQUALS {trykwd=1;} type_lengspec_name_kwd
    |
    type_lengspec_name_kwd
    ;


lengspec:
		{ $$ = varleng; }
	| SSTAR intonlyon expr intonlyoff
		{
		expptr p;
		p = $3;
		NO66("length specification *n");
		if( ! ISICON(p) || p->constblock.Const.ci <= 0 )
			{
			$$ = 0;
            if(!cxx)
            {
			    dclerr("length must be a positive integer constant",
				    NPNULL);
            }
        }
		else {
			if (vartype == TYCHAR)
				$$ = p->constblock.Const.ci;
			else switch((int)p->constblock.Const.ci) {
				case 1:	$$ = 1; break;
				case 2: $$ = typesize[TYSHORT];	break;
				case 4: $$ = typesize[TYLONG];	break;
				case 8: $$ = typesize[TYDREAL];	break;
				case 16: $$ = typesize[TYDCOMPLEX]; break;
				default:
					dclerr("invalid length",NPNULL);
					$$ = varleng;
				}
			}
		}
	| SSTAR intonlyon SLPAR SSTAR SRPAR intonlyoff
		{ NO66("length specification *(*)"); $$ = -1; }
	;

lengspec_or_dims:
		{ $$ = mkintcon(varleng); }
	| SSTAR intonlyon expr intonlyoff
		{
            if(cxx){
                $$ = $3;
            } else {
		    expptr p;
		    p = $3;
		    NO66("length specification *n");
		    if( ! ISICON(p) || p->constblock.Const.ci <= 0 )
			    {
			    $$ = mkintcon(0);
                if(!cxx)
                {
			        dclerr("length must be a positive integer constant",
				        NPNULL);
                }
            }
		    else {
			    if (vartype == TYCHAR)
				    $$ = mkintcon(p->constblock.Const.ci);
			    else switch((int)p->constblock.Const.ci) {
				    case 1:	$$ = mkintcon(1); break;
				    case 2: $$ = mkintcon(typesize[TYSHORT]);	break;
				    case 4: $$ = mkintcon(typesize[TYLONG]);	break;
				    case 8: $$ = mkintcon(typesize[TYDREAL]);	break;
				    case 16: $$ = mkintcon(typesize[TYDCOMPLEX]); break;
				    default:
					    dclerr("invalid length",NPNULL);
					    $$ = mkintcon(varleng);
				    }
			    }
		    }
        }
    
	| SSTAR intonlyon SLPAR SSTAR SRPAR intonlyoff
		{ NO66("length specification *(*)"); $$ = mkintcon(-1); }
	;

common:	  SCOMMON in_dcl var
		{ incomm( $$ = comblock("") , $3 ); }
	| SCOMMON in_dcl comblock var
		{ $$ = $3;  incomm($3, $4); }
	| common opt_comma comblock opt_comma var
		{ $$ = $3;  incomm($3, $5); }
	| common SCOMMA var
		{ incomm($1, $3); }
	;

comblock:  SCONCAT
		{ $$ = comblock(""); }
	| SSLASH SNAME SSLASH
		{ $$ = comblock(token); }
	;

external: SEXTERNAL in_dcl name
		{ setext($3); }
	| external SCOMMA name
		{ setext($3); }
	;

intrinsic:  SINTRINSIC in_dcl name
		{ NO66("INTRINSIC statement"); setintr($3); }
	| intrinsic SCOMMA name
		{ setintr($3); }
	;

equivalence:  SEQUIV in_dcl equivset
	| equivalence SCOMMA equivset
	;

equivset:  SLPAR equivlist SRPAR
		{
		struct Equivblock *p;
		if(nequiv >= maxequiv)
			many("equivalences", 'q', maxequiv);
		p  =  & eqvclass[nequiv++];
		p->eqvinit = NO;
		p->eqvbottom = 0;
		p->eqvtop = 0;
		p->equivs = $2;
		}
	;

equivlist:  lhs
		{ $$=ALLOC(Eqvchain);
		  $$->eqvitem.eqvlhs = (struct Primblock *)$1;
		}
	| equivlist SCOMMA lhs
		{ $$=ALLOC(Eqvchain);
		  $$->eqvitem.eqvlhs = (struct Primblock *) $3;
		  $$->eqvnextp = $1;
		}
	;

data:	  SDATA in_data datalist
	| data opt_comma datalist
	;

in_data:
		{ if(parstate == OUTSIDE)
			{
			newproc();
			startproc(ESNULL, CLMAIN);
			}
		  if(parstate < INDATA)
			{
			enddcl();
			parstate = INDATA;
			datagripe = 1;
			}
		}
	;

datalist:  datainit datavarlist SSLASH datapop vallist SSLASH
		{ if(!cxx){
          ftnint junk;
		  if(nextdata(&junk) != NULL)
			err("too few initializers");
            }
		  frdata($2);
		  frrpl();
		}
	;

datainit: /* nothing */ { frchain(&datastack); curdtp = 0; }

datapop: /* nothing */ { pop_datastack(); }

vallist:  { toomanyinit = NO; }  val
	| vallist SCOMMA val
	;

val:	  value
		{ dataval(ENULL, $1); }
	| simple SSTAR value
		{ dataval($1, $3); }
	;

value:	
    name SLPAR funarglist SRPAR            //       %prec SOPCALL
		{ 
		  $$ = mkexpr(OPINIT, (expptr)$1, convert_to_init_list((expptr)mklist($3))); 
        }
    |
  simple
	| addop simple
		{ if( $1==OPMINUS && ISCONST($2) )
			consnegop((Constp)$2);
		  $$ = $2;
		}
	/* | complex_const */
	;

savelist: saveitem
	| savelist SCOMMA saveitem
	;

saveitem: name
		{ int k;
		  $1->vsave = YES;
		  k = $1->vstg;
		if( ! ONEOF(k, M(STGUNKNOWN)|M(STGBSS)|M(STGINIT)) )
			dclerr("can only save static variables", $1);
		}
	| comblock
	;

paramlist:  paramitem
	| paramlist SCOMMA paramitem
	;

paramitem:  name SEQUALS expr
		{ if($1->vclass == CLUNKNOWN)
			make_param((Paramblock *)$1, ATTRIBUTE_PARAMETER, $3);
		  else dclerr("cannot make into parameter", $1);
		}
//    | name SEQUALS SLPARSLASH {needwkey_if_seen_type_dcolon=1;/*skjdhg*/} opt_type paraminits SSLASHRPAR
//		{ if($1->vclass ==  CLUNKNOWN)
//			make_param((Paramblock *)$1, ATTRIBUTE_PARAMETER, $6);
//		  else dclerr("cannot make into parameter", $1);
//		}
    | name SEQUALS SRESHAPE {int kasjhgjkasdgkj = 42;} SLPAR expr SCOMMA const_array SCOMMA {needkwd  =  1;} SORDER SEQUALS const_array SRPAR
		{ 
        if($1->vclass ==  CLUNKNOWN)
			make_param((Paramblock *)$1, ATTRIBUTE_PARAMETER, $6);
		  else dclerr("cannot make into parameter", $1);
        }
//    |    
//    SLPARSLASH {needwkey_if_seen_type_dcolon=1;/*skjdhg*/} opt_type paraminits SSLASHRPAR
//		{ if($1->vclass ==  CLUNKNOWN)
//			make_param((Paramblock *)$1, ATTRIBUTE_PARAMETER, $6);
//		  else dclerr("cannot make into parameter", $1);
//		}
	;
    

const_array_items:
    const_array_items SCOMMA expr
    |
    expr
    ;

const_array:
    SLPARSLASH const_array_items SSLASHRPAR
    ;


paraminit:  
//    SLPAR expr SCOMMA name SEQUALS expr SCOMMA expr SRPAR
//    {
//        chainp p = mkchain((char *)$8, CHNULL);
//        p = mkchain((char *)$6, p);
//        p = mkchain((char *)$2, p);
//        Listblock * l = mklist(p);
//        l->tag = TSPECIALLIST;
//        l->vtype = VTSPECIALLIST_IMPLIED_DO;
//        $$ = mkchain((char *)l, CHNULL);
//    }
//    |
        expr_do_list
		{ $$ = mkchain((char *)$1, CHNULL); }
      |
        expr
		{ $$ = mkchain((char *)$1, CHNULL); }
;


opt_type:
        /* empty */  {needwkey_if_seen_type_dcolon=0;}   
        |
        type SCOLON SCOLON


paraminits:  
        paraminit
		{ $$ = $1; }
	| paraminits SCOMMA paraminit
		{ $$ = hookup($3, $1); }
	;



var:	  name dims
		{ if(ndim>0) setbound($1, ndim, dims, 0); }
	;

datavar:	  lhs
		{ Namep np;
		  np = ( (struct Primblock *) $1) -> namep;
		  vardcl(np);
		  if(np->vstg == STGCOMMON)
			extsymtab[np->vardesc.varno].extinit = YES;
		  else if(np->vstg==STGEQUIV)
			eqvclass[np->vardesc.varno].eqvinit = YES;
		  else if(np->vstg!=STGINIT && np->vstg!=STGBSS)
			dclerr("inconsistent storage classes", np);
		  $$ = mkchain((char *)$1, CHNULL);
		}
	| SLPAR datavarlist SCOMMA dospec SRPAR
		{ chainp p; struct Impldoblock *q;
		pop_datastack();
		q = ALLOC(Impldoblock);
		q->tag = TIMPLDO;
		(q->varnp = (Namep) ($4->datap))->vimpldovar = 1;
		p = $4->nextp;
		if(p)  { q->implb = (expptr)(p->datap); p = p->nextp; }
		if(p)  { q->impub = (expptr)(p->datap); p = p->nextp; }
		if(p)  { q->impstep = (expptr)(p->datap); }
		frchain2( $4 );
		$$ = mkchain((char *)q, CHNULL);
		q->datalist = hookup($2, $$);
		}
	;

datavarlist: datavar
		{ if (!datastack)
			curdtp = 0;
		  datastack = mkchain((char *)curdtp, datastack);
		  curdtp = $1; curdtelt = 0;
		  }
	| datavarlist SCOMMA datavar
		{ $$ = hookup($1, $3); }
	;


dims_type:
    {in_dims_type = true; ndim_type = 0;}    // init
    dims                // scan
    {in_dims_type = false; ndim_type = ndim; ndim = 0;} // remember
    ;

dims:
		{ ndim = 0; }
	| SLPAR dimlist SRPAR
	;

dimlist:   { ndim = 0; }   dim
	| dimlist SCOMMA dim
	;

dim:	  ubound
		{
          Dims* cur_dims = in_dims_type ? dims_type : dims;
		  if(ndim == maxdim)
			err("too many dimensions");
		  else if(ndim < maxdim)
			{ cur_dims[ndim].lb = 0;
			  cur_dims[ndim].ub = $1;
			}
		  ++ndim;
		}
	| expr SCOLON ubound
		{
          Dims* cur_dims = in_dims_type ? dims_type : dims;
		  if(ndim == maxdim)
			err("too many dimensions");
		  else if(ndim < maxdim)
			{ cur_dims[ndim].lb = $1;
			  cur_dims[ndim].ub = $3;
			}
		  ++ndim;
		}
	| SCOLON
		{
          Dims* cur_dims = in_dims_type ? dims_type : dims;
		  if(ndim == maxdim)
			err("too many dimensions");
		  else if(ndim < maxdim)
			{ cur_dims[ndim].lb = nullptr;
			  cur_dims[ndim].ub = nullptr;
			}
		  ++ndim;
		}
	;

ubound:	  SSTAR
		{ $$ = 0; }
	| expr
	;

labellist: label
		{ nstars = 1; labarray[0] = $1; }
	| labellist SCOMMA label
		{ if(nstars < maxlablist)  labarray[nstars++] = $3; }
	;

label:	  SICON
		{ $$ = execlab( convci(toklen, token) ); }
	;

implicit:  SIMPLICIT in_dcl implist
		{ NO66("IMPLICIT statement"); }
	| implicit SCOMMA implist
	;

opt_intrinsic:
    /*empty*/
    |
    SCOMMA {needkwd = 1; /*oiuqwe*/} SINTRINSIC
    ;

opt_dcolon:
    /*empty*/
    |
    SCOLON SCOLON
    ;


only_names:  
        SNAME
	| only_names SCOMMA SNAME
	;

opt_onlys:
    /*empty*/
    |
    SCOMMA {needkwd=1;} SONLY SCOLON only_names
    ;

use:  SUSE opt_intrinsic opt_dcolon SNAME { exuse(token); } opt_onlys
	;

implist:  imptype SLPAR letgroups SRPAR
	| imptype
		{ if (vartype != TYUNKNOWN)
			dclerr("-- expected letter range",NPNULL);
		  setimpl(vartype, varleng, 'a', 'z'); }
	;

imptype:   { needkwd = 1; } type
		/* { vartype = $2; } */
	;

letgroups: letgroup
	| letgroups SCOMMA letgroup
	;

letgroup:  letter
		{ setimpl(vartype, varleng, $1, $1); }
	| letter SMINUS letter
		{ setimpl(vartype, varleng, $1, $3); }
	;

letter:  SNAME
		{ if(toklen!=1 || token[0]<'a' || token[0]>'z')
			{
			dclerr("implicit item must be single letter", NPNULL);
			$$ = 0;
			}
		  else $$ = token[0];
		}
	;

namelist:	SNAMELIST
	| namelist namelistentry
	;

namelistentry:  SSLASH name SSLASH namelistlist
		{
		if($2->vclass == CLUNKNOWN)
			{
			$2->vclass = CLNAMELIST;
			$2->vtype = TYINT;
			$2->vstg = STGBSS;
			$2->varxptr.namelist = $4;
			$2->vardesc.varno = ++lastvarno;
			}
		else dclerr("cannot be a namelist name", $2);
		}
	;

namelistlist:  name
		{ $$ = mkchain((char *)$1, CHNULL); }
	| namelistlist SCOMMA name
		{ $$ = hookup($1, mkchain((char *)$3, CHNULL)); }
	;

in_dcl:
		{ switch(parstate)
			{
            case OUTSIDE:
                parstate = INTYPEDCL;
                break;

		//	case OUTSIDE:
        //    	newproc();
		//			startproc(ESNULL, CLMAIN);
			case INSIDE:	parstate = INDCL;
			case INDCL:	break;
			case INTYPEDCL:	break;

			case INDATA:
				if (datagripe) {
					errstr(
				"Statement order error: declaration after DATA",
						CNULL);
					datagripe = 0;
					}
				break;

			default:
				dclerr("declaration among executables", NPNULL);
			}
		}
	;
funarglist:
        { $$ = 0; }
    | funargs
        { $$ = revchain($1); }
    ;

funarg:  
    in_substring
        { 
            Listblock * l = mklist($1);
            l->tag = TSPECIALLIST;
            l->vtype = VTSPECIALLIST_SUBARRAY;
            $$ = (expptr)l;
        }
    |
    expr
        { $$ = $1; }
        |
    SSOURCE SEQUALS expr
    { $$ = mkexpr(OP_OPT_SOURCE, $3, ENULL);; }
    |
    SSTAT SEQUALS expr
    { $$ = mkexpr(OP_OPT_STAT, $3, ENULL);; }
    ;

funargs:  
//    in_substring
//		{ 
//            Listblock * l = mklist($1);
//            l->tag = TSPECIALLIST;
//            l->vtype = VTSPECIALLIST_SUBARRAY;
//            $$ = mkchain((char *)l, CHNULL);
//        }
//    |
//    expr
//		{ $$ = mkchain((char *)$1, CHNULL); }
//	| funargs SCOMMA expr
//		{ $$ = mkchain((char *)$3, $1); }
    funarg
        { $$ = mkchain((char *)$1, CHNULL); }
    | funargs SCOMMA funarg
        { $$ = mkchain((char *)$3, $1); }
    ;


expr:	  uexpr
    | SLPAR expr SRPAR	{ $$ = $2; if ($$->tag == TPRIM)
                    $$->primblock.parenused = 1; }
    /* | complex_const */
    ;

uexpr:	  lhs_base
    | simple_const
    | expr addop expr   %prec SPLUS
        { $$ = mkexpr($2, $1, $3); }
    | expr SSTAR expr
        { $$ = mkexpr(OPSTAR, $1, $3); }
    | expr SSLASH expr
        { $$ = mkexpr(OPSLASH, $1, $3); }
    | expr SPOWER expr
        { $$ = mkexpr(OPPOWER, $1, $3); }
    | addop expr  %prec SSTAR
        { if($1 == OPMINUS)
            $$ = mkexpr(OPNEG, $2, ENULL);
          else 	$$ = $2;
        }
    | expr relop expr  %prec SEQ
        { $$ = mkexpr($2, $1, $3); }
    | expr SEQV expr
        { NO66(".EQV. operator");
          $$ = mkexpr(OPEQV, $1,$3); }
    | expr SNEQV expr
        { NO66(".NEQV. operator");
          $$ = mkexpr(OPNEQV, $1, $3); }
    | expr SOR expr
        { $$ = mkexpr(OPOR, $1, $3); }
    | expr SAND expr
        { $$ = mkexpr(OPAND, $1, $3); }
    | SNOT expr
        { $$ = mkexpr(OPNOT, $2, ENULL); }
    | expr SCONCAT expr
        { NO66("concatenation operator //");
          $$ = mkexpr(cxx ? OPSTRCAT : OPCONCAT, $1, $3);
           }

    | expr SLPAR funarglist SRPAR            //       %prec SOPCALL
        { 
          $$ = mkexpr(OPCALL, $1, (expptr)mklist($3)); 
        }
    | expr  expr_member_access  
        { $$ = mkopmember(OPMEMBER, $1, $2); }
//	| expr SDOT expr_member_access  
//		{ $$ = mkopmember(OPMEMBER, $1, $3); }
//    | SLPARSLASH expr_do_list SSLASHRPAR
//		{ $$ = $2; }
   | SLPARSLASH {needwkey_if_seen_type_dcolon=1;} opt_type paraminits SSLASHRPAR
        {$$ = convert_to_init_list((expptr)mklist(revchain($4)));}
   ;


expr_member_access:
    SMEMBER {in_member_access = true; } expr 
    { in_member_access = false; $$ = $3; }
    |
    SDOT {in_member_access = true; } expr
    { in_member_access = false; $$ = $3; }
    ;

expr_do_list:
    SLPAR expr SCOMMA name SEQUALS expr SCOMMA expr SRPAR
    {
        chainp p = mkchain((char *)$8, CHNULL);
        p = mkchain((char *)$6, p);
        p = mkchain((char *)$4, p);
        p = mkchain((char *)$2, p);
        Listblock * l = mklist(p);
        l->tag = TSPECIALLIST;
        l->vtype = VTSPECIALLIST_IMPLIED_DO;
        $$ = (expptr)l;
    }


//	| expr SLPAR funarglist SRPAR substring         %prec SOPCALL
//		{ NO66("substring operator :");
//		  $$ = mkprim($1, mklist($3), $5); }
    ;

addop:	  SPLUS		{ $$ = OPPLUS; }
    | SMINUS	{ $$ = OPMINUS; }
    ;

relop:	  SEQ	{ $$ = OPEQ; }
    | SGT	{ $$ = OPGT; }
    | SLT	{ $$ = OPLT; }
    | SGE	{ $$ = OPGE; }
    | SLE	{ $$ = OPLE; }
    | SNE	{ $$ = OPNE; }
    ;

lhs:	 name
        { $$ = mkprim($1, LBNULL, CHNULL); }
    | name substring
        { NO66("substring operator :");
          $$ = mkprim($1, LBNULL, $2); }
    | name SLPAR funarglist SRPAR
        { $$ = mkprim($1, mklist($3), CHNULL); }
    | name SLPAR funarglist SRPAR substring
        { NO66("substring operator :");
          $$ = mkprim($1, mklist($3), $5); }
    ;
    
lhs_base:	 name
        { $$ = mkprim($1, LBNULL, CHNULL); }
/*
    | name substring
        { NO66("substring operator :");
          $$ = mkprim($1, LBNULL, $2); }
*/
//	| lhs SMEMBER lhs  
//		{ $$ = mkopmember(OPMEMBER, $1, $3); }
//
//	| lhs SLPAR funarglist SRPAR                   %prec SOPCALL
//		{ $$ = mkprim($1, mklist($3), CHNULL); }
// 	| lhs SLPAR funarglist SRPAR substring         %prec SOPCALL
// 		{ NO66("substring operator :");
// 		  $$ = mkprim($1, mklist($3), $5); }

    ;

in_substring:  
        opt_expr SCOLON opt_expr
        { $$ = mkchain((char *)$1, 
                mkchain((char *)$3,
                mkchain((char *)0,CHNULL  ))); }
                |
        opt_expr SCOLON opt_expr SCOLON opt_expr
        { $$ = mkchain((char *)$1, 
                mkchain((char *)$3,
                mkchain((char *)$5,CHNULL  ))); }
    ;

substring:  
        SLPAR in_substring SRPAR
        { $$ = $2 }
    ;

opt_expr:
        { $$ = 0; }
    | expr
    ;

simple:	  name
        {
        /* TODO
         if($1->vclass == CLPARAM)
            $$ = (expptr) cpexpr(
                ( (Paramblock *) ($1) ) -> paramval);
        */
        }
    | simple_const
    ;

simple_const:   STRUE	{ $$ = mklogcon(1); }
    | SFALSE	{ $$ = mklogcon(0); }
    | SHOLLERITH  { $$ = mkstrcon(toklen, token); }
    | SICON	 { $$ = mkintcon( convci(toklen, token) ); }
    | SRCON	 { $$ = mkrealcon(tyreal, token); }
    | SDCON	 { $$ = mkrealcon(TYDREAL, token); }
    | bit_const
    ;

    /*
complex_const:  SLPAR uexpr SCOMMA uexpr SRPAR
        { $$ = mkcxcon($2,$4); }
    ;
    */

bit_const:  SHEXCON
        { NOEXT("hex constant");
          $$ = mkbitcon(4, toklen, token); }
    | SOCTCON
        { NOEXT("octal constant");
          $$ = mkbitcon(3, toklen, token); }
    | SBITCON
        { NOEXT("binary constant");
          $$ = mkbitcon(1, toklen, token); }
    ;

fexpr:	  unpar_fexpr
    | SLPAR fexpr SRPAR
        { $$ = $2; }
    ;

unpar_fexpr:	  lhs
    | simple_const
    | fexpr addop fexpr   %prec SPLUS
        { $$ = mkexpr($2, $1, $3); }
    | fexpr SSTAR fexpr
        { $$ = mkexpr(OPSTAR, $1, $3); }
    | fexpr SSLASH fexpr
        { $$ = mkexpr(OPSLASH, $1, $3); }
    | fexpr SPOWER fexpr
        { $$ = mkexpr(OPPOWER, $1, $3); }
    | addop fexpr  %prec SSTAR
        { if($1 == OPMINUS)
            $$ = mkexpr(OPNEG, $2, ENULL);
          else	$$ = $2;
        }
    | fexpr SCONCAT fexpr
        { NO66("concatenation operator //");
          $$ = mkexpr(cxx ? OPSTRCAT : OPCONCAT, $1, $3); }
    ;
exec:	  iffable
	| SDO end_spec intonlyon label intonlyoff opt_comma dospecw
		{
		if($4->labdefined)
			execerr("no backward DO loops", CNULL);
		$4->blklevel = blklevel+1;
		exdo($4->labelno, NPNULL, $7);
		}
	| SDO end_spec opt_comma dospecw
		{
		exdo((int)(ctls - ctlstack - 2), NPNULL, $4);
		NOEXT("DO without label");
		}
	| SENDDO
		{ exenddo(NPNULL); }
	| logif iffable
		{ exendif();  thiswasbranch = NO; }
	| logif STHEN 
	| SELSEIF end_spec SLPAR expr SRPAR STHEN
		{ exelif($4); lastwasbranch = NO; }
	| SELSE end_spec
		{ exelse(); lastwasbranch = NO; }
	| SENDIF end_spec
		{ exendif(); lastwasbranch = NO; }
    | SSELECT end_spec { needkwd = 1; } SCASE SLPAR expr SRPAR
		{ exselect($6); }
	| SENDSELECT
		{ exendselect(); }
    | SCASE casedecl
		{ excase($2); }
    | SCASEDEFAULT
		{ excase(0); }
	| SDOCONCURRENT end_spec doconcspec
		{
		exdoconc((int)(ctls - ctlstack - 2), $3);
		}
	; 


logif:	  SLOGIF end_spec SLPAR expr SRPAR
		{ exif($4); }
	;

dospec:	  name SEQUALS exprlist
		{ $$ = mkchain((char *)$1, $3); }
	;


wherespecs:
    /* empty */
    { $$ = nullptr; }
    |
    SCOMMA expr wherespecs
    { $$ = mkchain((char *)$2, $3); }


doconcloop:	 
        name SEQUALS expr SCOLON expr 
        {
            chainp p = nullptr;
            p = mkchain(nullptr, nullptr);        // no step
            p = mkchain((char *)$5, p);
            p = mkchain((char *)$3, p);
            p = mkchain((char *)$1, p);
            $$ = p;
        }
        |
        name SEQUALS expr SCOLON expr SCOLON expr
        {
            chainp p = nullptr;
            p = mkchain((char *)$7, nullptr);        // no step
            p = mkchain((char *)$5, p);
            p = mkchain((char *)$3, p);
            p = mkchain((char *)$1, p);
            $$ = p;
        }
        ;
         
doconcloops:	
        doconcloop
        { $$ = mkchain((char *)$1, nullptr); }
        |
        doconcloops SCOMMA doconcloop
        { $$ =     hookup($1, mkchain((char *)$3, nullptr)) ; }
        ;

doconcspec:	
         SLPAR doconcloops wherespecs SRPAR
		{ 
            chainp p = nullptr;
            p = mkchain((char *)$3, nullptr);
            p = mkchain((char *)$2, p);
            $$ = p;
        }
	;

dospecw:  dospec
	| SWHILE SLPAR expr SRPAR
		{ $$ = mkchain(CNULL, (chainp)$3); }
	;

write_cxx:
    SWRITE end_spec SLPAR funarglist SRPAR funarglist
		{ 
            exwrite($4, $6);
        }
	;

pointer_integer: SPOINTER SLPAR expr SCOMMA expr SRPAR
		{ 
            putexpr(call2(TYUNKNOWN, "ft::pointer_integer", $3, $5));
        }

//alloc_attr:
//    SCOMMA SSOURCE SEQUALS expr
//    { $$ = nullptr; }
//    |
//    SCOMMA SSTAT SEQUALS expr
//    { $$ = nullptr; }
//    ;
//
//
//alloc_attrs:
//    alloc_attr
//    { $$ = nullptr; }
//    |
//    alloc_attrs alloc_attr
//    ;
//
//opt_alloc_attrs:
///    /* empty */
///    { $$ = nullptr; }
///    |
//    alloc_attrs
//    { $$ = $1; }
//    ;
//

allocate_cxx:
    SALLOCATE end_spec SLPAR funarglist SRPAR
		{ 
           exallocate($4, false);
        }
        |
    SDEALLOCATE end_spec SLPAR funarglist SRPAR
		{ 
           exallocate($4, true);
        }
	;


iffable:  let uexpr SEQUALS expr
          //let lhs SEQUALS expr
		{ exequals((struct Primblock *)$2, $4); }
	| SASSIGN end_spec assignlabel STO name
		{ exassign($5, $3); }
	| SCONTINUE end_spec
	| goto
    | write_cxx
    | allocate_cxx
    | pointer_integer
	| io
		{ inioctl = NO; }
	| SARITHIF end_spec SLPAR expr SRPAR label SCOMMA label SCOMMA label
		{ exarif($4, $6, $8, $10);  thiswasbranch = YES; }
	| call
		{ excall($1, LBNULL, 0, labarray); }
	| call SLPAR SRPAR
		{ excall($1, LBNULL, 0, labarray); }
	| call SLPAR callarglist SRPAR
		{ if(nstars < maxlablist)
			excall($1, mklist(revchain($3)), nstars, labarray);
		  else
			many("alternate returns", 'l', maxlablist);
		}
	| SRETURN end_spec opt_expr
		{ exreturn($3);  thiswasbranch = YES; }
	| stop end_spec opt_expr
		{ exstop($1, $3);  thiswasbranch = $1; }
    | SCYCLE
		{ excycle(); }
    | SEXIT
		{ exexit(); }
	;

assignlabel:   SICON
		{ $$ = mklabel( convci(toklen, token) ); }
	;

let:	  SLET
		{ if(parstate == OUTSIDE)
			{
			newproc();
			startproc(ESNULL, CLMAIN);
			}
		}
	;

goto:	  SGOTO end_spec label
		{ exgoto($3);  thiswasbranch = YES; }
	| SASGOTO end_spec name
		{ exasgoto($3);  thiswasbranch = YES; }
	| SASGOTO end_spec name opt_comma SLPAR labellist SRPAR
		{ exasgoto($3);  thiswasbranch = YES; }
	| SCOMPGOTO end_spec SLPAR labellist SRPAR opt_comma expr
		{ if(nstars < maxlablist)
			putcmgo(putx(fixtype($7)), nstars, labarray);
		  else
			many("labels in computed GOTO list", 'l', maxlablist);
		}
	;

opt_comma:
	| SCOMMA
	;

call:	  SCALL end_spec name
		{ nstars = 0; $$ = $3; }
	;

callarglist:  callarg
		{ $$ = $1 ? mkchain((char *)$1,CHNULL) : CHNULL; }
	| callarglist SCOMMA callarg
		{ $$ = $3 ? mkchain((char *)$3, $1) : $1; }
	;

callarg:  expr
	| SSTAR label
		{ if(nstars < maxlablist) labarray[nstars++] = $2; $$ = 0; }
	;

stop:	  SPAUSE
		{ $$ = 0; }
	| SSTOP
		{ $$ = 2; }
	;

caseval: 
/*
        SICON
        {$$ = mkintcon( convci(toklen, token) ); }
        |
        name
		{ $$ = (expptr)$1; }
        |
*/
        expr
		{ $$ = (expptr)$1; }


casespec:  caseval
        { 
            // single case as single element list
		    $$ = mkchain((char *)$1, CHNULL);
        }
        | caseval SCOLON caseval
        { 
            // bounded range
		    $$ = mkchain((char *)$1, CHNULL);
        }
        | caseval SCOLON
        { 
            // bounded range
		    $$ = mkchain((char *)$1, CHNULL);
        }
        | SCOLON caseval
        { 
            // bounded range
		    $$ = mkchain((char *)$2, CHNULL);
        }
	;

caselist:  casespec
		{ $$ = $1; }
	| caselist SCOMMA casespec
		{ $$ = hookup($1, $3); }
	;

casedecl: SLPAR caselist SRPAR {$$=$2;}


exprlist:  expr
		{ $$ = mkchain((char *)$1, CHNULL); }
	| exprlist SCOMMA expr
		{ $$ = hookup($1, mkchain((char *)$3,CHNULL) ); }
	;

end_spec:
		{ 
            if(parstate == OUTSIDE)
			{
			newproc();
			startproc(ESNULL, CLMAIN);
			}

/* This next statement depends on the ordering of the state table encoding */

		    if(parstate < INDATA) enddcl();
            }
	;

intonlyon:
		{ intonly = YES; }
	;

intonlyoff:
		{ intonly = NO; }
	;
  /*  Input/Output Statements */

io:	  io1
		{ endio(); }
	;

io1:	  iofmove ioctl
	| iofmove unpar_fexpr
		{ ioclause(IOSUNIT, $2); endioctl(); }
	| iofmove SSTAR
		{ ioclause(IOSUNIT, ENULL); endioctl(); }
	| iofmove SPOWER
		{ ioclause(IOSUNIT, IOSTDERR); endioctl(); }
	| iofctl ioctl
	| read ioctl
		{ doio(CHNULL); }
	| read infmt
		{ doio(CHNULL); }
	| read ioctl inlist
		{ doio(revchain($3)); }
	| read infmt SCOMMA inlist
		{ doio(revchain($4)); }
	| read ioctl SCOMMA inlist
		{ doio(revchain($4)); }
//	| write ioctl
//		{ doio(CHNULL); }
//	| write ioctl outlist
//		{ doio(revchain($3)); }
	| print
		{ doio(CHNULL); }
	| print SCOMMA outlist
		{ doio(revchain($3)); }
	;

iofmove:   fmkwd end_spec in_ioctl
	;

fmkwd:	  SBACKSPACE
		{ iostmt = IOBACKSPACE; }
	| SREWIND
		{ iostmt = IOREWIND; }
	| SENDFILE
		{ iostmt = IOENDFILE; }
	;

iofctl:  ctlkwd end_spec in_ioctl
	;

ctlkwd:	  SINQUIRE
		{ iostmt = IOINQUIRE; }
	| SOPEN
		{ iostmt = IOOPEN; }
	| SCLOSE
		{ iostmt = IOCLOSE; }
	;

infmt:	  unpar_fexpr
		{
		ioclause(IOSUNIT, ENULL);
		ioclause(IOSFMT, $1);
		endioctl();
		}
	| SSTAR
		{
		ioclause(IOSUNIT, ENULL);
		ioclause(IOSFMT, ENULL);
		endioctl();
		}
	;

ioctl:	  SLPAR fexpr SRPAR
		{
		  ioclause(IOSUNIT, $2);
		  endioctl();
		}
	| SLPAR ctllist SRPAR
		{ endioctl(); }
	;

ctllist:  ioclause
	| ctllist SCOMMA ioclause
	;

ioclause:  fexpr
		{ ioclause(IOSPOSITIONAL, $1); }
	| SSTAR
		{ ioclause(IOSPOSITIONAL, ENULL); }
	| SPOWER
		{ ioclause(IOSPOSITIONAL, IOSTDERR); }
	| nameeq expr
		{ ioclause($1, $2); }
	| nameeq SSTAR
		{ ioclause($1, ENULL); }
	| nameeq SPOWER
		{ ioclause($1, IOSTDERR); }
	;

nameeq:  SNAMEEQ
		{ $$ = iocname(); }
	;

read:	  SREAD end_spec in_ioctl
		{ iostmt = IOREAD; }
	;

// write:	  SWRITE end_spec in_ioctl
// 		{ iostmt = IOWRITE; }
// 	;

print:	  SPRINT end_spec fexpr in_ioctl
		{
		iostmt = IOWRITE;
		ioclause(IOSUNIT, ENULL);
		ioclause(IOSFMT, $3);
		endioctl();
		}
	| SPRINT end_spec SSTAR in_ioctl
		{
		iostmt = IOWRITE;
		ioclause(IOSUNIT, ENULL);
		ioclause(IOSFMT, ENULL);
		endioctl();
		}
	;

inlist:	  inelt
		{ $$ = mkchain((char *)$1, CHNULL); }
	| inlist SCOMMA inelt
		{ $$ = mkchain((char *)$3, $1); }
	;

inelt:	  lhs
		{ $$ = (tagptr) $1; }
	| SLPAR inlist SCOMMA dospec SRPAR
		{ $$ = (tagptr) mkiodo($4,revchain($2)); }
	;

outlist:  uexpr
		{ $$ = mkchain((char *)$1, CHNULL); }
	| other
		{ $$ = mkchain((char *)$1, CHNULL); }
	| out2
	;

out2:	  uexpr SCOMMA uexpr
		{ $$ = mkchain((char *)$3, mkchain((char *)$1, CHNULL) ); }
	| uexpr SCOMMA other
		{ $$ = mkchain((char *)$3, mkchain((char *)$1, CHNULL) ); }
	| other SCOMMA uexpr
		{ $$ = mkchain((char *)$3, mkchain((char *)$1, CHNULL) ); }
	| other SCOMMA other
		{ $$ = mkchain((char *)$3, mkchain((char *)$1, CHNULL) ); }
	| out2  SCOMMA uexpr
		{ $$ = mkchain((char *)$3, $1); }
	| out2  SCOMMA other
		{ $$ = mkchain((char *)$3, $1); }
	;

other:	  /*complex_const
		{ $$ = (tagptr) $1; }
	| */
        SLPAR expr SRPAR
		{ $$ = (tagptr) $2; }
	| SLPAR uexpr SCOMMA dospec SRPAR
		{ $$ = (tagptr) mkiodo($4, mkchain((char *)$2, CHNULL) ); }
	| SLPAR other SCOMMA dospec SRPAR
		{ $$ = (tagptr) mkiodo($4, mkchain((char *)$2, CHNULL) ); }
	| SLPAR out2  SCOMMA dospec SRPAR
		{ $$ = (tagptr) mkiodo($4, revchain($2)); }
	;

in_ioctl:
		{ startioctl(); }
	;
