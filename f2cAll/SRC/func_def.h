#ifndef __FUNC_DEF_H__ 
#define __FUNC_DEF_H__ 

#include "DEFS.H"

void Fatal(char *t);
void frchain(chainp *p);
void frchain2(chainp p);
void frexpr(tagptr p);
void err(const char *s);
void fatali(char *t, int d);
void warn1(char *s, char *t);
int cktype(int op, int lt, int rt);
void consconv(int lt, Constp lc, Constp rc);
void prconi(FILEP fp, ftnint n);
void prcona(FILEP fp, ftnint a);
void prconr(FILEP fp, Constp x, int k);
void badstg(char *r, int t);
void badtype(char *r, int t);
void many(char *s, char c, int n);
char *memname(int stg, long mem);
void impldcl(Namep p);
void warn(char *s);
void errstr(char *s, char *t);
void erri(char *s, int t);
void vardcl(Namep v);
void warni(char *s, int t);
void err66(char *s);
void errext(char *s);
void execerr(char *s, char *n);
void dclerr(char *s, Namep v);
expptr suboffset(struct Primblock *p);
int in_vector(char *str, char **keywds, int n);
void done(int k);
void putif(expptr p, int else_if_p);
void enddcl();
void settype(Namep v, int type, expptr length_ptr, int attribute);
void settype2(Namep v, ii_val_t const& type, expptr length_ptr);
void putcmgo(expptr index, int nlab, struct Labelblock *labs[]);
void putexpr(expptr p);
expptr mkstrcon(int l, char const*v);
int conssgn(expptr p);
conseval_t conseval(expptr p);
void deregister(Namep np);
void frtemp(Addrp p);
void putout(expptr p);
void fmtname(Namep np, Addrp q);
int addressable(expptr p);
void p1_asgoto(Addrp addrp);
void warn(char *s);
tagptr cpblock(int n, char * p);
void badtag(char *r, int t);
void badop(char *r, int t);
void badstg(char *r, int t);
Addrp mkscalar(Namep np);
int intrfunct(char *s);
void fatalstr(const char *t, const char *s);
void fatali(char *t, int d);
expptr intrcall(Namep np, struct Listblock *argsp, int nargs);
Addrp intraddr(Namep np);
int is_negatable(Constp Const);
int maxtype(int t1, int t2);
int cmpstr(char *a, char *b, ftnint la, ftnint lb);

void margin_printf(FILE *fp, const char *a, ...);
void nice_printf(FILE *fp, const char *a, ...);
int ind_printf(int use_indent, FILE *fp, const char *a, ...);
void out_and_free_statement(FILE *outfile, expptr expr);
int op_assign(int opcode);
int oneof_stg(Namep name, int stg, int mask);
char *lit_name(struct Literal *litp);
int isnegative_const(struct Constblock *cp);
void negate_const(Constp cp);
void clf(FILEP *p, char *what, int quit);
int dsort(char *from, char *to);
void backup(char *fname, char *bname);
int rdname(FILE *infile, int *vargroupp, char *name);
int rdlong(FILE *infile, ftnint *n);
void wr_nv_ident_help(FILE *outfile, struct Addrblock *addrp);
char *cpstring(char const *s);
void errl(char *s, long t);
void frexchain(chainp *p);
void setimpl(int type, ftnint length, int c1, int c2);
void setlog();
int lengtype(int type, ftnint len);
expptr mkcxcon(expptr realp, expptr imagp);
int fixargs(int doput, struct Listblock *p0);
void cast_args(int maxtype, chainp args);
int newlabel();
char *lexline(int *n);
void flline();
struct Labelblock *execlab(ftnint stateno);
Addrp autovar(int nelt0, proctype_t t, expptr lengp, char *name, bool is_retval);
void exdo(int range, Namep loopname, chainp spec);
void exdoconc(int range, chainp spec);
void enddo(int here, bool needs_breakout_for, int loops_count);
Addrp mkscalar(Namep np);
ftnint lencat(expptr p);
void exif(expptr p);
void exgoto(struct Labelblock *lab);
void p1_label(long lab);
void exendif();
int isstatic(expptr p);
expptr mkaddcon(long l);
Addrp putchop(expptr p);
void badthing(char *thing, char *r, int t);
void doinclude(char *name, bool from_parse);
int eqn(int n, char *a, char *b);
void fileinit();
void read_Pfiles(char **ffiles);
int dofork();
void initkey();
std::string c_name(std::string s, std::string ft);
std::string get_extension(std::string s);
int inilex(char *name);
void procinit();
int yyparse();
void wr_common_decls(FILE *outfile);
void list_init_data(FILE **Infile, char *Inname, FILE *outfile);
void wr_globals(FILE *outfile);
void ffilecopy(FILE *infp, FILE *outfp);
void def_commons(FILE *of);
void endproc();
void Un_link_all(int cdelete);
char *wr_ardecls(FILE *outfile, struct Dimblock *dimp, long size);
char *Argtype(int k, char *buf);
chainp length_comp(struct Entrypoint *e, int add_n);
void listargs(FILE *outfile, struct Entrypoint *entryp, int add_n_, chainp lengths);
void list_arg_types(FILE *outfile, struct Entrypoint *entryp, chainp lengths, int add_n_, char *finalnl, bool is_proto);
void start_formatting(bool no_prev_indent);
void doequiv();
void puthead(char *s, int class_);
Namep mkname(char *s);
void prolog(FILE *outfile, chainp p);
expptr make_int_expr(expptr e);
Addrp mkarg(int type, int argno);
void save_argtypes(chainp arglist, Argtypes **at0, Argtypes **at1, int ccall, char *fname, int stg, int nchargs, int type, int zap);
int struct_eq(chainp s1, chainp s2);
void cpn(int n, char *a, char *b);
expptr mkrealcon(int t, char *d);
void new_endif();
int log_2(ftnint n);
Addrp realpart(Addrp p);
expptr imagpart(Addrp p);
int badchleng(expptr p);
int ncat(expptr p);
struct Listblock *mklist(chainp p);
void wr_abbrevs(FILE *outfile, int function_head, chainp vars);
void other_undefs(FILE *outfile);
void procode(FILE *outfile);
void changedtype(Namep q);
ftnint wr_char_len(FILE *outfile, struct Dimblock *dimp, int n, int extra1);
char *equiv_name(int memno, char *store);
void bad_atypes(Argtypes *at, char *fname, int i, int j, int k, char *here, char *prev);
void startproc(Extsym * progname, int class_);
void startioctl();
void endioctl();
void doio(chainp list);
void ioclause(int n, expptr p);
struct Impldoblock *mkiodo(chainp dospec, chainp list);
void exasgoto(Namep labvar);
int iocname();
void endio();
expptr mkbitcon(int shift, int leng, char *s);
void excall(Namep name, struct Listblock *args, int nstars, struct Labelblock *labels[]);
void exassign(Namep vname, struct Labelblock *labelval);
void exequals(struct Primblock *lp, expptr rp);
void exelse();
void exendif();
void exelif(expptr p);
void exenddo(Namep np);
void exarif(expptr expr, struct Labelblock *neglab, struct Labelblock *zerlab, struct Labelblock *poslab);
void exselect(expptr p);
void excase(chainp p);
void excycle();
void exexit();

void exendselect();
void exreturn(expptr p);
void exstop(int stop, expptr p);
void yyerror(const char *s);
void newproc();
void newmodule();
expptr mklogcon(int l);
void setbound(Namep  v, int nd, struct Dims dims[], expptr lengspec_or_dims);
void consnegop(Constp p);
void dataval(expptr repp, expptr valp);
void dataval_exp(expptr datap);
void frrpl();
void incomm(Extsym *c, Namep v);
void setext(Namep  v);
void frdata(chainp p0);
Addrp nextdata(ftnint *elenp);
void entrypt(int class_, int type, ftnint length, Extsym *entry, chainp args, chainp postfixes);
void setintr(Namep  v);
Extsym *comblock(char *s);
int fmtstmt(struct Labelblock *lp);
void setfmt(struct Labelblock *lp);
int yylex();

bool is_const(expptr p);



void exmodule(const char* name);
void excontains();
void exendmodule();
void exuse(const char* name);
void putmodulehead();

void add_global_include(const char* name, bool is_use);

void endtype();
void newtype(const char* name);
void type_hashclear();

int length_from_name(const char* name);

void exwrite(chainp p0, chainp p1);
void exallocate(chainp p, bool deallocate);

#endif //__FUNC_DEF_H__

