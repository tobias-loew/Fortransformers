/****************************************************************
Copyright 1990, 1991, 1992, 1993 by AT&T Bell Laboratories and Bellcore.

Permission to use, copy, modify, and distribute this software
and its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the names of AT&T Bell Laboratories or
Bellcore or any of their entities not be used in advertising or
publicity pertaining to distribution of the software without
specific, written prior permission.

AT&T and Bellcore disclaim all warranties with regard to this
software, including all implied warranties of merchantability
and fitness.  In no event shall AT&T or Bellcore be liable for
any special, indirect or consequential damages or any damages
whatsoever resulting from loss of use, data or profits, whether
in an action of contract, negligence or other tortious action,
arising out of or in connection with the use or performance of
this software.
****************************************************************/

/* Format.c -- this file takes an intermediate file (generated by pass 1
   of the translator) and some state information about the contents of that
   file, and generates C program text. */

#include <vector>
#include <algorithm>
#include <boost/scope_exit.hpp>
#include "defs.h"
#include "func_def.h"
#include "p1defs.h"
#include "format.h"
#include "output.h"
#include "names.h"
#include "iob.h"
#include <string>
#include <sstream>

int c_output_line_length = DEF_C_LINE_LENGTH;
int c_comment_output_line_length = DEF_C_COMMENT_LINE_LENGTH;
extern std::vector<derived_type> new_types;
extern bool redirect_to_proto;
bool allocating = false;
int last_was_label;	/* Boolean used to generate semicolons
                   when a label terminates a block */
static char this_proc_name[52];	/* Name of the current procedure.  This is
                   probably too simplistic to handle
                   multiple entry points */

bool is_function_parameter(chainp parameters, expptr lb, expptr ub, std::vector<std::string>& names);
bool write_cxx_type(FILE *outfile, Namep var, bool add_const_ref, chainp parameters, bool is_const_param);
void list_decls(FILE *outfile, bool is_module_head, chainp parameters);
static expptr do_format(FILE *infile, FILE *outfile);
static int p1getd(FILE *infile, long *result);
static int p1getf(FILE *infile, char **result);
static int p1gets(FILE *fp, char *str, int size);
static int get_p1_token(FILE *infile);
static int p1get_const(FILE *infile, int type, struct Constblock **resultp);
static int p1getn(FILE *infile, int count, char **result);
static expptr do_p1_name_pointer(FILE *infile);
static expptr do_p1_const(FILE* infile);
static expptr do_p1_extern(FILE *infile);
static expptr do_p1_charp(FILE *infile);
static expptr do_p1_ident(FILE *infile);
static expptr do_p1_expr(FILE *infile, FILE *outfile);
static expptr do_p1_head(FILE *infile, FILE *outfile);
static expptr do_p1_list(FILE *infile, FILE *outfile);
static expptr do_p1_literal(FILE *infile);
static void do_p1_label(FILE *infile, FILE *outfile);
static void do_p1_asgoto(FILE *infile, FILE *outfile);
static void do_p1_goto(FILE *infile, FILE *outfile);
static void do_p1_if(FILE *infile, FILE *outfile);
static void do_p1_else(FILE *outfile);
static void do_p1_endif(FILE *outfile);
static void do_p1_elif(FILE *infile, FILE *outfile);
static void do_p1_endelse(FILE *outfile);
static void do_p1_subr_ret(FILE *infile, FILE *outfile);
static void do_p1_comp_goto(FILE *infile, FILE *outfile);
static void do_p1_for(FILE *infile, FILE *outfile);
static void do_p1_end_for(FILE *infile, FILE *outfile);
static void do_p1_fortran(FILE *infile, FILE *outfile);
static void do_p1_1while(FILE *outfile);
static void do_p1_2while(FILE *infile, FILE *outfile);
static void do_p1_elseifstart(FILE *outfile);
static void do_p1_set_line(FILE *infile);
static void do_p1_comment(FILE *infile, FILE *outfile);
static void do_p1_switch(FILE *infile, FILE *outfile);
static void do_p1_end_switch(FILE *outfile);
static void do_p1_case(FILE *infile, FILE *outfile);
static void do_p1_case_open(FILE *infile, FILE *outfile);
static void do_p1_end_case(FILE *outfile);
static void do_p1_namespace(FILE *infile, FILE *outfile);
static void do_p1_end_namespace(FILE *infile, FILE *outfile);
static void do_p1_include(FILE *infile, FILE *outfile);
static void do_p1_using_namespace(FILE *infile, FILE *outfile);
static expptr do_p1_modulehead(FILE *infile, FILE *outfile);
static void do_p1_struct(FILE *infile, FILE *outfile);
static void do_p1_continue(FILE *infile, FILE *outfile);
static void do_p1_break(FILE *infile, FILE *outfile);
static void do_p1_goto_breakout_for(FILE *infile, FILE *outfile);
static void do_p1_write_cxx(FILE *infile, FILE *outfile);
static void do_p1_allocate(FILE *infile, FILE *outfile, bool deallocate);


static expptr do_p1_addr(FILE *infile, FILE *outfile);
static void proto(FILE *outfile, Argtypes *at, char *fname);
void do_uninit_equivs(FILE *outfile, int *did_one);
//void list_arg_types();
chainp length_comp();
//void listargs();
extern chainp assigned_fmts;
static char filename[P1_FILENAME_MAX];
extern int gflag;
int gflag1;
extern char *parens;
extern flag no_var_pooling; /* do not pool local variables */
extern flag unused_vars; /* output unused variables */
extern flag symbolic_params; /* use symbolic params/const */
extern flag cxx; /* use modern c++ (implies a lot) */


void start_formatting(bool no_prev_indent)
{
    FILE *infile;
    static int wrote_one = 0;
    extern int usedefsforcommon;
    extern char *p1_file, *p1_bakfile;

    this_proc_name[0] = '\0';
    last_was_label = 0;
    ei_next = ei_first;
    wh_next = wh_first;

    (void)fclose(pass1_file);
    if((infile = fopen(p1_file, binread)) == NULL)
        Fatal("start_formatting:  couldn't open the intermediate file\n");


    FILE* output_file = redirect_to_proto ? protofile : c_file;

    if(wrote_one)
        nice_printf(output_file, "\n");

    while(!feof(infile)) {
        expptr this_expr;

        this_expr = do_format(infile, output_file);
        if(this_expr) {
            out_and_free_statement(output_file, this_expr);
        } /* if this_expr */
    } /* while !feof infile */

    (void)fclose(infile);

    if(last_was_label)
        nice_printf(output_file, ";\n");

    if(!no_prev_indent)
    {
        prev_tab(output_file);
    }
    gflag1 = 0;
    if(this_proc_name[0])
        nice_printf(output_file, "} /* %s */\n", this_proc_name);


    /* Write the #undefs for common variable reference */

    if(usedefsforcommon) {
        Extsym *ext;
        int did_one = 0;

        for(ext = extsymtab; ext < nextext; ext++)
            if(ext->extstg == STGCOMMON && ext->used_here) {
                ext->used_here = 0;
                if(!did_one)
                    nice_printf(output_file, "\n");
                wr_abbrevs(output_file, 0, ext->extp);
                did_one = 1;
                ext->extp = CHNULL;
            } /* if */

        if(did_one)
            nice_printf(output_file, "\n");
    } /* if usedefsforcommon */

    other_undefs(output_file);

    wrote_one = 1;

/* For debugging only */

    if(debugflag && (pass1_file = fopen(p1_bakfile, binwrite)))
        if(infile = fopen(p1_file, binread)) {
            ffilecopy(infile, pass1_file);
            fclose(infile);
            fclose(pass1_file);
        } /* if infile */

    /* End of "debugging only" */

    scrub(p1_file);	/* optionally unlink */

    if((pass1_file = fopen(p1_file, binwrite)) == NULL)
        err("start_formatting:  couldn't reopen the pass1 file");

} /* start_formatting */


static void
put_semi(FILE *outfile)
 //FILE *outfile;
{
    nice_printf(outfile, ";\n");
    last_was_label = 0;
}

#define SEM_CHECK(x) if (last_was_label) put_semi(x)

/* do_format -- takes an input stream (a file in pass1 format) and writes
   the appropriate C code to   outfile   when possible.  When reading an
   expression, the expression tree is returned instead. */

static expptr do_format(FILE *infile, FILE *outfile)
//FILE *infile, *outfile;
{
    int token_type, was_c_token;
    expptr retval = ENULL;

    token_type = get_p1_token(infile);
    was_c_token = 1;
    switch(token_type) {
    case P1_COMMENT:
        do_p1_comment(infile, outfile);
        was_c_token = 0;
        break;
    case P1_SET_LINE:
        do_p1_set_line(infile);
        was_c_token = 0;
        break;
    case P1_FILENAME:
        p1gets(infile, filename, P1_FILENAME_MAX);
        was_c_token = 0;
        break;
    case P1_NAME_POINTER:
        retval = do_p1_name_pointer(infile);
        break;
    case P1_CONST:
        retval = do_p1_const(infile);
        break;
    case P1_EXPR:
        retval = do_p1_expr(infile, outfile);
        break;
    case P1_IDENT:
        retval = do_p1_ident(infile);
        break;
    case P1_CHARP:
        retval = do_p1_charp(infile);
        break;
    case P1_EXTERN:
        retval = do_p1_extern(infile);
        break;
    case P1_HEAD:
        gflag1 = 0;
        retval = do_p1_head(infile, outfile);
        gflag1 = gflag;
        break;
    case P1_MODULEHEAD:
        gflag1 = 0;
        retval = do_p1_modulehead(infile, outfile);
        gflag1 = gflag;
        break;
    case P1_LIST:
        retval = do_p1_list(infile, outfile);
        break;
    case P1_LITERAL:
        retval = do_p1_literal(infile);
        break;
    case P1_LABEL:
        do_p1_label(infile, outfile);
        /* last_was_label = 1; -- now set in do_p1_label */
        was_c_token = 0;
        break;
    case P1_ASGOTO:
        do_p1_asgoto(infile, outfile);
        break;
    case P1_GOTO:
        do_p1_goto(infile, outfile);
        break;
    case P1_IF:
        do_p1_if(infile, outfile);
        break;
    case P1_ELSE:
        SEM_CHECK(outfile);
        do_p1_else(outfile);
        break;
    case P1_ELIF:
        SEM_CHECK(outfile);
        do_p1_elif(infile, outfile);
        break;
    case P1_ENDIF:
        SEM_CHECK(outfile);
        do_p1_endif(outfile);
        break;
    case P1_ENDELSE:
        SEM_CHECK(outfile);
        do_p1_endelse(outfile);
        break;
    case P1_ADDR:
        retval = do_p1_addr(infile, outfile);
        break;
    case P1_SUBR_RET:
        do_p1_subr_ret(infile, outfile);
        break;
    case P1_COMP_GOTO:
        do_p1_comp_goto(infile, outfile);
        break;
    case P1_FOR:
        do_p1_for(infile, outfile);
        break;
    case P1_ENDFOR:
        SEM_CHECK(outfile);
        do_p1_end_for(infile, outfile);
        break;
    case P1_WHILE1START:
        do_p1_1while(outfile);
        break;
    case P1_WHILE2START:
        do_p1_2while(infile, outfile);
        break;
    case P1_PROCODE:
        procode(outfile);
        break;
    case P1_ELSEIFSTART:
        SEM_CHECK(outfile);
        do_p1_elseifstart(outfile);
        break;
    case P1_SWITCH:
        do_p1_switch(infile, outfile);
        break;
    case P1_ENDSWITCH:
        SEM_CHECK(outfile);
        do_p1_end_switch(outfile);
        break;
    case P1_CASE:
        do_p1_case(infile, outfile);
        break;
    case P1_CASE_OPEN:
        do_p1_case_open(infile, outfile);
        break;
    case P1_ENDCASE:
        SEM_CHECK(outfile);
        do_p1_end_case(outfile);
        break;
    case P1_FORTRAN:
        do_p1_fortran(infile, outfile);
        /* no break; */
    case P1_EOF:
        was_c_token = 0;
        break;
    case P1_NAMESPACE:
        do_p1_namespace(infile, outfile);
        break;
    case P1_ENDNAMESPACE:
        do_p1_end_namespace(infile, outfile);
        break;
    case P1_INCLUDE:
        do_p1_include(infile, outfile);
        break;
    case P1_USING_NAMESPACE:
        do_p1_using_namespace(infile, outfile);
        break;
    case P1_STRUCT:
        do_p1_struct(infile, outfile);
        break;
    case P1_CONTINUE:
        do_p1_continue(infile, outfile);
        break;
    case P1_BREAK:
        do_p1_break(infile, outfile);
        break;
    case P1_GOTO_BREAKOUT_FOR:
        do_p1_goto_breakout_for(infile, outfile);
        break;
    case P1_WRITE_CXX:
        do_p1_write_cxx(infile, outfile);
        break;
    case P1_ALLOCATE:
        do_p1_allocate(infile, outfile, false);
        break;
    case P1_DEALLOCATE:
        do_p1_allocate(infile, outfile, true);
        break;
    //case P1_REDIRECT_TO_PROT_START:
    //    //do_p1_allocate(infile, outfile);
    //    break;
    //case P1_REDIRECT_TO_PROT_END:
    //    //do_p1_allocate(infile, outfile);
    //    break;
    case P1_UNKNOWN:
        Fatal("do_format:  Unknown token type in intermediate file");
        break;
    default:
        Fatal("do_format:  Bad token type in intermediate file");
        break;
    } /* switch */

    if(was_c_token)
        last_was_label = 0;
    return retval;
} /* do_format */


static void
do_p1_comment(FILE *infile, FILE *outfile)
//FILE *infile, *outfile;
{
    extern int c_output_line_length, in_comment;
    extern int c_comment_output_line_length;

    char storage[COMMENT_BUFFER_SIZE + 1];
    int length;

    if(!p1gets(infile, storage, COMMENT_BUFFER_SIZE + 1))
        return;

    length = strlen(storage);

    gflag1 = 0;
    in_comment = 1;
    if(cxx && !strchr(storage, '\n')){
        margin_printf(outfile, "// %s\n", storage);
    }
    else
    {
        if(length > c_output_line_length - 6)
            margin_printf(outfile, "/*%s*/\n", storage);
        else
            margin_printf(outfile, length ? "/* %s */\n" : "\n", storage);
    }
    in_comment = 0;
    gflag1 = gflag;
} /* do_p1_comment */

static void
do_p1_set_line(FILE *infile)
//FILE *infile;
{
    int status;
    long new_line_number = -1;

    status = p1getd(infile, &new_line_number);

    if(status == EOF)
        err("do_p1_set_line:  Missing line number at end of file\n");
    else if(status == 0 || new_line_number == -1)
        errl("do_p1_set_line:  Illegal line number in intermediate file: %ld\n",
            new_line_number);
    else {
        lineno = new_line_number;
    }
} /* do_p1_set_line */


static expptr do_p1_name_pointer(FILE *infile)
//FILE *infile;
{
    Namep namep = (Namep)NULL;
    int status;

    status = p1getd(infile, (long *)&namep);

    if(status == EOF)
        err("do_p1_name_pointer:  Missing pointer at end of file\n");
    else if(status == 0 || namep == (Namep)NULL)
        erri("do_p1_name_pointer:  Illegal name pointer in p1 file: '%x'\n",
        (int)namep);

    return (expptr)namep;
} /* do_p1_name_pointer */



static expptr do_p1_const(FILE* infile)
//FILE *infile;
{
    struct Constblock *c = (struct Constblock *) NULL;
    long type = -1;
    int status;

    status = p1getd(infile, &type);

    if(status == EOF)
        err("do_p1_const:  Missing constant type at end of file\n");
    else if(status == 0)
        errl("do_p1_const:  Illegal constant type in p1 file: %ld\n", type);
    else {
        status = p1get_const(infile, (int)type, &c);

        if(status == EOF) {
            err("do_p1_const:  Missing constant value at end of file\n");
            c = (struct Constblock *) NULL;
        }
        else if(status == 0) {
            err("do_p1_const:  Illegal constant value in p1 file\n");
            c = (struct Constblock *) NULL;
        } /* else */
    } /* else */
    return (expptr)c;
} /* do_p1_const */


static expptr do_p1_literal(FILE *infile)
//FILE *infile;
{
    int status;
    long memno;
    Addrp addrp;

    status = p1getd(infile, &memno);

    if(status == EOF)
        err("do_p1_literal:  Missing memno at end of file");
    else if(status == 0)
        err("do_p1_literal:  Missing memno in p1 file");
    else {
        struct Literal *litp, *lastlit;

        addrp = ALLOC(Addrblock);
        addrp->tag = TADDR;
        addrp->vtype = TYUNKNOWN;
        addrp->Field = NULL;

        lastlit = litpool + nliterals;
        for(litp = litpool; litp < lastlit; litp++)
            if(litp->litnum == memno) {
                addrp->vtype = (field)litp->littype;
                *((union Constant *) &(addrp->user)) =
                    *((union Constant *) &(litp->litval));
                break;
            } /* if litp -> litnum == memno */

        addrp->memno = memno;
        addrp->vstg = STGMEMNO;
        addrp->uname_tag = UNAM_CONST;
    } /* else */

    return (expptr)addrp;
} /* do_p1_literal */


static void do_p1_label(FILE *infile, FILE *outfile)
//FILE *infile, *outfile;
{
    int status;
    ftnint stateno;
    struct Labelblock *L;
    char *fmt;

    status = p1getd(infile, &stateno);

    if(status == EOF)
        err("do_p1_label:  Missing label at end of file");
    else if(status == 0)
        err("do_p1_label:  Missing label in p1 file ");
    else if(stateno < 0) {	/* entry */
        margin_printf(outfile, "\n%s:\n", user_label(stateno));
        last_was_label = 1;
    }
    else {
        L = labeltab + stateno;
        if(L->labused) {
            fmt = "%s:\n";
            last_was_label = 1;
        }
        else
            fmt = "/* %s: */\n";
        margin_printf(outfile, fmt, user_label(L->stateno));
    } /* else */
} /* do_p1_label */



static void do_p1_asgoto(FILE *infile, FILE *outfile)
//FILE *infile, *outfile;
{
    expptr expr;

    expr = do_format(infile, outfile);
    out_asgoto(outfile, expr);

} /* do_p1_asgoto */


static void do_p1_goto(FILE *infile, FILE *outfile)
//FILE *infile, *outfile;
{
    int status;
    long stateno;

    status = p1getd(infile, &stateno);

    if(status == EOF)
        err("do_p1_goto:  Missing goto label at end of file");
    else if(status == 0)
        err("do_p1_goto:  Missing goto label in p1 file");
    else {
        nice_printf(outfile, "goto %s;\n", user_label(stateno));
    } /* else */
} /* do_p1_goto */


static void do_p1_if(FILE *infile, FILE *outfile)
{
    expptr cond;

    do {
        cond = do_format(infile, outfile);
    } while(cond == ENULL);

    out_if(outfile, cond);
} /* do_p1_if */


static void do_p1_else(FILE *outfile)
//FILE *outfile;
{
    out_else(outfile);
} /* do_p1_else */


static void do_p1_elif(FILE *infile, FILE *outfile)
//FILE *infile, *outfile;
{
    expptr cond;

    do {
        cond = do_format(infile, outfile);
    } while(cond == ENULL);

    elif_out(outfile, cond);
} /* do_p1_elif */

static void do_p1_endif(FILE *outfile)
//FILE *outfile;
{
    endif_out(outfile);
} /* do_p1_endif */


static void do_p1_endelse(FILE *outfile)
//FILE *outfile;
{
    end_else_out(outfile);
} /* do_p1_endelse */


static expptr do_p1_addr(FILE *infile, FILE *outfile)
//FILE *infile, *outfile;
{
    Addrp addrp = (Addrp)NULL;
    int status;

    status = p1getn(infile, (int)sizeof(struct Addrblock), (char **)&addrp);

    if(status == EOF)
        err("do_p1_addr:  Missing Addrp at end of file");
    else if(status == 0)
        err("do_p1_addr:  Missing Addrp in p1 file");
    else if(addrp == (Addrp)NULL)
        err("do_p1_addr:  Null addrp in p1 file");
    else if(addrp->tag != TADDR)
        erri("do_p1_addr: bad tag in p1 file '%d'", addrp->tag);
    else {
        addrp->vleng = do_format(infile, outfile);
        addrp->memoffset = do_format(infile, outfile);
    }

    return (expptr)addrp;
} /* do_p1_addr */



static void do_p1_subr_ret(FILE *infile, FILE *outfile)
//FILE *infile, *outfile;
{
    expptr retval;

    nice_printf(outfile, "return");
    retval = do_format(infile, outfile);
    if(!multitype)
        if(retval)
        {
            nice_printf(outfile, " ");
            expr_out(outfile, retval);
        }

    nice_printf(outfile, ";\n");
} /* do_p1_subr_ret */



static void do_p1_comp_goto(FILE *infile, FILE *outfile)
//FILE *infile, *outfile;
{
    expptr index;
    expptr labels;

    index = do_format(infile, outfile);

    if(index == ENULL) {
        err("do_p1_comp_goto:  no expression for computed goto");
        return;
    } /* if index == ENULL */

    labels = do_format(infile, outfile);

    if(labels && labels->tag != TLIST)
        erri("do_p1_comp_goto:  expected list, got tag '%d'", labels->tag);
    else
        compgoto_out(outfile, index, labels);
} /* do_p1_comp_goto */


static void do_p1_for(FILE *infile, FILE *outfile)
//FILE *infile, *outfile;
{
    expptr init, test, inc, limit;

    init = do_format(infile, outfile);
    test = do_format(infile, outfile);
    inc = do_format(infile, outfile);
    limit = do_format(infile, outfile);

    out_for(outfile, init, test, inc);
    if(dolimitconstflag && limit) {
        nice_printf(outfile, "CONSTIFY(");
        expr_out(outfile, limit);
        nice_printf(outfile, "); \n");
    }
    else {
        free((char *)limit);
    }

} /* do_p1_for */

static void do_p1_end_for(FILE *infile, FILE *outfile)
//FILE *outfile;
{
    long needs_breakout_for;
    long loops_count;
    auto status = p1getd(infile, &needs_breakout_for);
    status = p1getd(infile, &loops_count);

    out_end_for(outfile, needs_breakout_for, loops_count);
} /* do_p1_end_for */

static void do_p1_switch(FILE *infile, FILE *outfile)
{
    expptr value;

    value = do_format(infile, outfile);

    out_switch(outfile, value);
} /* do_p1_switch */

static void do_p1_end_switch(FILE *outfile)
{
    out_end_switch(outfile);
} /* do_p1_end_switch */

static void do_p1_case(FILE *infile, FILE *outfile)
{
    expptr case_ = do_format(infile, outfile);
    expptr lower = do_format(infile, outfile);
    expptr upper = do_format(infile, outfile);

    out_case(outfile, case_, lower, upper);

} /* do_p1_case */

static void do_p1_case_open(FILE *infile, FILE *outfile)
{
    out_case_open(outfile);

} /* do_p1_case */

static void do_p1_end_case(FILE *outfile)
{
    out_end_case(outfile);
} /* do_p1_end_switch */

void do_p1_namespace(FILE *infile, FILE *outfile){
    char buf[P1_STMTBUFSIZE];
    if(!p1gets(infile, buf, P1_STMTBUFSIZE))
        return;

    nice_printf(outfile, "namespace %s {\n", buf);

    if(redirect_to_proto)
    {
        nice_printf(c_file, "namespace %s {\n", buf);
    }
    else
    {
        nice_printf(protofile, "namespace %s {\n", buf);
    }
}
void do_p1_end_namespace(FILE *infile, FILE *outfile){
    char buf[P1_STMTBUFSIZE];
    if(!p1gets(infile, buf, P1_STMTBUFSIZE))
        return;

    nice_printf(outfile, "} // namespace %s\n", buf);

    nice_printf(protofile, "} // namespace %s\n", buf);
}

void do_p1_include(FILE *infile, FILE *outfile){
    char buf[P1_STMTBUFSIZE];
    if(!p1gets(infile, buf, P1_STMTBUFSIZE))
        return;

    nice_printf(outfile, "#include \"%s\"\n", buf);
}

void do_p1_using_namespace(FILE *infile, FILE *outfile){
    char buf[P1_STMTBUFSIZE];
    if(!p1gets(infile, buf, P1_STMTBUFSIZE))
        return;


    if(redirect_to_proto)
    {
        nice_printf(c_file, "using namespace %s;\n", buf);
    }
    else
    {
        nice_printf(outfile, "using namespace %s;\n", buf);
    }

}

void do_struct_member(Namep var, FILE *infile, FILE *outfile){

    int class_ = var->vclass;
    if(class_ == CLPARAM)
    {
        if(var->vdim)
        {
            // constexpr only allowed for literal types
//            nice_printf(outfile, "static FT_CONST /*constexpr*/ ");
            nice_printf(outfile, "static constexpr ");
        }
        else
        {
            nice_printf(outfile, "static constexpr ");
        }
    }

    write_cxx_type(outfile, var, false, nullptr, class_ == CLPARAM);
    nice_printf(outfile, "%s", var->cvarname);

    if(var->paramval /*class_ == CLPARAM*/)
    {
        Paramblock* param = (Paramblock*)var;
        if(param->paramval && param->paramval->nextp)
        {
            // two or more...
            nice_printf(outfile, "= { ");
            for(auto e_ = param->paramval; e_; e_ = e_->nextp)
            {
                auto e = (expptr)e_->datap;

                expr_out(outfile, cpexpr(e));

                if(e_->nextp){
                    nice_printf(outfile, ", ");
                }
                else {
                    nice_printf(outfile, " }");
                }
            }
        }
        else
        {
            // single value initialization
            nice_printf(outfile, "= ");
            for(auto e_ = param->paramval; e_; e_ = e_->nextp)
            {
                auto e = (expptr)e_->datap;

                expr_out(outfile, cpexpr(e));

                if(e_->nextp){
                    nice_printf(outfile, ", ");
                }
            }
        }


    }

    nice_printf(outfile, ";\n");

}

void do_p1_continue(FILE *infile, FILE *outfile){
    nice_printf(outfile, "continue;\n");
}

void do_p1_break(FILE *infile, FILE *outfile){
    nice_printf(outfile, "break;\n");
}

void do_p1_goto_breakout_for(FILE *infile, FILE *outfile){
    nice_printf(outfile, "goto breakout_for;\n");
}

void do_p1_write_cxx(FILE *infile, FILE *outfile){
    auto p0 = do_format(infile, outfile);
    auto p1 = do_format(infile, outfile);
    nice_printf(outfile, "ft::format(");
    expr_out(outfile, p0);
    nice_printf(outfile, ")(");
    expr_out(outfile, p1);
    nice_printf(outfile, ");\n");
}

void do_p1_allocate(FILE *infile, FILE *outfile, bool deallocate){

    bool allocating_local = allocating;
    BOOST_SCOPE_EXIT(allocating_local){
        allocating = allocating_local;
    }BOOST_SCOPE_EXIT_END
    if(!deallocate)
    {
        allocating = true;
    }

    auto p0 = do_format(infile, outfile);
    if(deallocate)
    {
        nice_printf(outfile, "ft::deallocate(");
    }
    else
    {
        nice_printf(outfile, "ft::allocate(");
    }
    expr_out(outfile, p0);
    nice_printf(outfile, ");\n");
}

void do_p1_struct(FILE *infile, FILE *outfile){
    long count;
    p1getd(infile, &count);
    char buf[P1_STMTBUFSIZE];
    if(!p1gets(infile, buf, P1_STMTBUFSIZE))
        return;

    char buf2[P1_STMTBUFSIZE];
    if(!p1gets(infile, buf2, P1_STMTBUFSIZE))
        return;

    std::string b2 = buf2;
    if(b2.empty())
    {
        nice_printf(outfile, "struct  %s {\n", buf);
    }
    else
    {
        nice_printf(outfile, "struct  %s : %s {\n", buf, b2.c_str());
    }

    next_tab(outfile);
    for(long i = 0; i < count; ++i)
    {
        auto np = do_format(infile, outfile);
        do_struct_member((Namep)np, infile, outfile);
    }
    prev_tab(outfile);
    nice_printf(outfile, "};\n");
}

static void
do_p1_fortran(FILE *infile, FILE *outfile)
 //FILE *infile, *outfile;
{
    char buf[P1_STMTBUFSIZE];
    if(!p1gets(infile, buf, P1_STMTBUFSIZE))
        return;
    /* bypass nice_printf nonsense */
    fprintf(outfile, "/*< %s >*/\n", buf + 1);	/* + 1 to skip by '$' */
}


static expptr do_p1_expr(FILE *infile, FILE *outfile)
//FILE *infile, *outfile;
{
    int status;
    long opcode, type;
    struct Exprblock *result = (struct Exprblock *) NULL;

    status = p1getd(infile, &opcode);

    if(status == EOF)
        err("do_p1_expr:  Missing expr opcode at end of file");
    else if(status == 0)
        err("do_p1_expr:  Missing expr opcode in p1 file");
    else {

        status = p1getd(infile, &type);

        if(status == EOF)
            err("do_p1_expr:  Missing expr type at end of file");
        else if(status == 0)
            err("do_p1_expr:  Missing expr type in p1 file");
        else if(opcode == 0)
            return ENULL;
        else {
            result = ALLOC(Exprblock);

            result->tag = TEXPR;
            result->vtype = (field)type;
            result->opcode = opcode;
            result->vleng = do_format(infile, outfile);

            if(is_unary_op(opcode))
                result->leftp = do_format(infile, outfile);
            else if(is_binary_op(opcode)) {
                result->leftp = do_format(infile, outfile);
                result->rightp = do_format(infile, outfile);
            }
            else
                errl("do_p1_expr:  Illegal opcode %ld", opcode);
        } /* else */
    } /* else */

    return (expptr)result;
} /* do_p1_expr */


static expptr do_p1_ident(FILE *infile)
//FILE *infile;
{
    Addrp addrp;
    int status;
    long vtype, vstg;

    addrp = ALLOC(Addrblock);
    addrp->tag = TADDR;

    status = p1getd(infile, &vtype);
    if(status == EOF)
        err("do_p1_ident:  Missing identifier type at end of file\n");
    else if(status == 0 || vtype < 0 || vtype >= NTYPES0)
        errl("do_p1_ident:  Bad type in intermediate file: %ld\n", vtype);
    else
        addrp->vtype = (field)vtype;

    status = p1getd(infile, &vstg);
    if(status == EOF)
        err("do_p1_ident:  Missing identifier storage at end of file\n");
    else if(status == 0 || vstg < 0 || vstg > STGNULL)
        errl("do_p1_ident:  Bad storage in intermediate file: %ld\n", vtype);
    else
        addrp->vstg = (field)vstg;

    status = p1gets(infile, addrp->user.ident, IDENT_LEN);

    if(status == EOF)
        err("do_p1_ident:  Missing ident string at end of file");
    else if(status == 0)
        err("do_p1_ident:  Missing ident string in intermediate file");
    addrp->uname_tag = UNAM_IDENT;
    return (expptr)addrp;
} /* do_p1_ident */

static expptr do_p1_charp(FILE *infile)
//FILE *infile;
{
    Addrp addrp;
    int status;
    long vtype, vstg;
    char buf[64];

    addrp = ALLOC(Addrblock);
    addrp->tag = TADDR;

    status = p1getd(infile, &vtype);
    if(status == EOF)
        err("do_p1_ident:  Missing identifier type at end of file\n");
    else if(status == 0 || vtype < 0 || vtype >= NTYPES)
        errl("do_p1_ident:  Bad type in intermediate file: %ld\n", vtype);
    else
        addrp->vtype = (field)vtype;

    status = p1getd(infile, &vstg);
    if(status == EOF)
        err("do_p1_ident:  Missing identifier storage at end of file\n");
    else if(status == 0 || vstg < 0 || vstg > STGNULL)
        errl("do_p1_ident:  Bad storage in intermediate file: %ld\n", vtype);
    else
        addrp->vstg = (field)vstg;

    status = p1gets(infile, buf, (int)sizeof(buf));

    if(status == EOF)
        err("do_p1_ident:  Missing charp ident string at end of file");
    else if(status == 0)
        err("do_p1_ident:  Missing charp ident string in intermediate file");
    addrp->uname_tag = UNAM_CHARP;
    addrp->user.Charp = strcpy(mem(strlen(buf) + 1, 0), buf);
    return (expptr)addrp;
}


static expptr do_p1_extern(FILE *infile)
//FILE *infile;
{
    Addrp addrp;

    addrp = ALLOC(Addrblock);
    if(addrp) {
        int status;

        addrp->tag = TADDR;
        addrp->vstg = STGEXT;
        addrp->uname_tag = UNAM_EXTERN;
        status = p1getd(infile, &(addrp->memno));
        if(status == EOF)
            err("do_p1_extern:  Missing memno at end of file");
        else if(status == 0)
            err("do_p1_extern:  Missing memno in intermediate file");
        if(addrp->vtype = extsymtab[addrp->memno].extype)
            addrp->vclass = CLPROC;
    } /* if addrp */

    return (expptr)addrp;
} /* do_p1_extern */



static expptr do_p1_head(FILE *infile, FILE *outfile)
//FILE *infile, *outfile;
{
    int status;
    int add_n_;
    long class_;
    char storage[256];

    status = p1getd(infile, &class_);
    if(status == EOF)
        err("do_p1_head:  missing header class_ at end of file");
    else if(status == 0)
        err("do_p1_head:  missing header class_ in p1 file");
    else {
        status = p1gets(infile, storage, (int)sizeof(storage));
        if(status == EOF || status == 0)
            storage[0] = '\0';
    } /* else */

    if(class_ == CLPROC || class_ == CLMAIN) {
        chainp lengths;

        add_n_ = nentry > 1;
        lengths = length_comp(entries, add_n_);

        if(!add_n_ && protofile && class_ != CLMAIN)
            protowrite(protofile, proctype, storage, entries, lengths);

        if(class_ == CLMAIN)
            nice_printf(outfile, "/* Main program */ int ");
        else
        {
            if(cxx)
            { 
                write_cxx_type(outfile, std::get<0>(proctype), false, nullptr, class_ == CLPARAM);
            }
            else
            {
                nice_printf(outfile, "%s ", multitype ? "VOID"
                    : cpp2_type_decl(proctype, 1, false).c_str());
            }
        }

        nice_printf(outfile, add_n_ ? "%s0_" : "%s", storage);
        if(!Ansi) {
            listargs(outfile, entries, add_n_, lengths);
            nice_printf(outfile, "\n");
        }
        list_arg_types(outfile, entries, lengths, add_n_, "\n", false);
        nice_printf(outfile, "{\n");
        frchain(&lengths);
        next_tab(outfile);
        strcpy(this_proc_name, storage);
        list_decls(outfile, false, entries->arglist);

    }
    else if(class_ == CLBLOCK)
        next_tab(outfile);
    else
        errl("do_p1_head: got class_ %ld", class_);

    return NULL;
} /* do_p1_head */

static expptr do_p1_modulehead(FILE *infile, FILE *outfile)
//FILE *infile, *outfile;
{
    //int status;
    //int add_n_;
    //long class_;
    //char storage[256];

    list_decls(outfile, true, nullptr);

    //status = p1getd(infile, &class_);
    //if(status == EOF)
    //    err("do_p1_head:  missing header class_ at end of file");
    //else if(status == 0)
    //    err("do_p1_head:  missing header class_ in p1 file");
    //else {
    //    status = p1gets(infile, storage, (int)sizeof(storage));
    //    if(status == EOF || status == 0)
    //        storage[0] = '\0';
    //} /* else */

    //if(class_ == CLPROC || class_ == CLMAIN) {
    //    chainp lengths;

    //    add_n_ = nentry > 1;
    //    lengths = length_comp(entries, add_n_);

    //    if(!add_n_ && protofile && class_ != CLMAIN)
    //        protowrite(protofile, proctype, storage, entries, lengths);

    //    if(class_ == CLMAIN)
    //        nice_printf(outfile, "/* Main program */ ");
    //    else
    //        nice_printf(outfile, "%s ", multitype ? "VOID"
    //            : cpp_type_decl(proctype, 1));

    //    nice_printf(outfile, add_n_ ? "%s0_" : "%s", storage);
    //    if(!Ansi) {
    //        listargs(outfile, entries, add_n_, lengths);
    //        nice_printf(outfile, "\n");
    //    }
    //    list_arg_types(outfile, entries, lengths, add_n_, "\n");
    //    nice_printf(outfile, "{\n");
    //    frchain(&lengths);
    //    next_tab(outfile);
    //    strcpy(this_proc_name, storage);
    //    list_decls(outfile);

    //}
    //else if(class_ == CLBLOCK)
    //    next_tab(outfile);
    //else
    //    errl("do_p1_head: got class_ %ld", class_);

    return NULL;
} /* do_p1_head */


static expptr do_p1_list(FILE *infile, FILE *outfile)
//FILE *infile, *outfile;
{
    long tag, type, count;
    int status;
    expptr result;

    status = p1getd(infile, &tag);
    if(status == EOF)
        err("do_p1_list:  missing list tag at end of file");
    else if(status == 0)
        err("do_p1_list:  missing list tag in p1 file");
    else {
        status = p1getd(infile, &type);
        if(status == EOF)
            err("do_p1_list:  missing list type at end of file");
        else if(status == 0)
            err("do_p1_list:  missing list type in p1 file");
        else {
            status = p1getd(infile, &count);
            if(status == EOF)
                err("do_p1_list:  missing count at end of file");
            else if(status == 0)
                err("do_p1_list:  missing count in p1 file");
        } /* else */
    } /* else */

    result = (expptr)ALLOC(Listblock);
    if(result) {
        chainp pointer;

        result->tag = (field)tag;
        result->listblock.vtype = (field)type;

    /* Assume there will be enough data */

        if(count--) {
            pointer = result->listblock.listp =
                mkchain((char *)do_format(infile, outfile), CHNULL);
            while(count--) {
                pointer->nextp =
                    mkchain((char *)do_format(infile, outfile), CHNULL);
                pointer = pointer->nextp;
            } /* while (count--) */
        } /* if (count) */
    } /* if (result) */

    return result;
} /* do_p1_list */


chainp length_comp(struct Entrypoint *e, int add_n)	/* get lengths of characters args */
 //struct Entrypoint *e;
 //int add_n;
{
    chainp lengths;
    chainp args, args1;
    Namep arg, np;
    int nchargs;
    Argtypes *at;
    Atype *a;
    extern int init_ac[NTYPES + 1];

    if(!e)
        return 0;	/* possible only with errors */
    args = args1 = add_n ? allargs : e->arglist;
    nchargs = 0;
    for(lengths = NULL; args; args = args->nextp)
        if(arg = (Namep)args->datap) {
            if(arg->vclass == CLUNKNOWN)
                arg->vclass = CLVAR;
            if(!cxx)
            {
                if(arg->vtype == TYCHAR && arg->vclass != CLPROC) {
                    lengths = mkchain((char *)arg, lengths);
                    nchargs++;
                }
            }
        }
    if(!add_n && (np = e->enamep)) {
        /* one last check -- by now we know all we ever will
         * about external args...
         */
        save_argtypes(e->arglist, &e->entryname->arginfo,
            &np->arginfo, 0, np->fvarname, STGEXT, nchargs,
            np->vtype, 1);
        at = e->entryname->arginfo;
        a = at->atypes + init_ac[np->vtype];
        for(; args1; a++, args1 = args1->nextp) {
            frchain(&a->cp);
            if(arg = (Namep)args1->datap)
                switch(arg->vclass) {
                case CLPROC:
                    if(arg->vimpltype
                        && a->type >= 300)
                        a->type = TYUNKNOWN + 200;
                    break;
                case CLUNKNOWN:
                    a->type %= 100;
                }
        }
    }
    return revchain(lengths);
}

void listargs(FILE *outfile, struct Entrypoint *entryp, int add_n_, chainp lengths)
 //FILE *outfile;
 //struct Entrypoint *entryp;
 //int add_n_;
 //chainp lengths;
{
    chainp args;
    char *s;
    Namep arg;
    int did_one = 0;

    nice_printf(outfile, "(");

    if(add_n_) {
        nice_printf(outfile, "n__");
        did_one = 1;
        args = allargs;
    }
    else {
        if(!entryp)
            return;	/* possible only with errors */
        args = entryp->arglist;
    }

    if(!cxx)
    {
        if(multitype)
        {
            nice_printf(outfile, ", ret_val");
            did_one = 1;
            args = allargs;
        }
        else if(ONEOF(std::get<2>(proctype), MSKCOMPLEX | MSKCHAR))
        {
            s = xretslot[std::get<2>(proctype)]->user.ident;
            nice_printf(outfile, did_one ? ", %s" : "%s",
                *s == '(' /*)*/ ? "r_v" : s);
            did_one = 1;
            if(std::get<2>(proctype) == TYCHAR)
                nice_printf(outfile, ", ret_val_len");
        }
    }
    for(; args; args = args->nextp)
        if(arg = (Namep)args->datap) {
            nice_printf(outfile, "%s", did_one ? ", " : "");
            out_name(outfile, arg);
            did_one = 1;
        }

    for(args = lengths; args; args = args->nextp)
        nice_printf(outfile, ", %s",
            new_arg_length((Namep)args->datap));
    nice_printf(outfile, ")");
} /* listargs */


void list_arg_types(FILE *outfile, struct Entrypoint *entryp, chainp lengths, int add_n_, char *finalnl, bool is_proto)
//FILE *outfile;
//struct Entrypoint *entryp;
//chainp lengths;
//int add_n_;
//char *finalnl;
{
    chainp args;
    int last_type = -1, last_class = -1;
    int did_one = 0, done_one, is_ext;
    char *s, *sep = "", *sep1;

    if(outfile == (FILE *)NULL) {
        err("list_arg_types:  null output file");
        return;
    }
    else if(entryp == (struct Entrypoint *) NULL) {
        err("list_arg_types:  null procedure entry pointer");
        return;
    } /* else */

    if(Ansi) {
        done_one = 0;
        sep1 = ", ";
        nice_printf(outfile, "(" /*)*/);
    }
    else {
        done_one = 1;
        sep1 = ";\n";
    }
    args = entryp->arglist;
    if(add_n_) {
        nice_printf(outfile, "int n__");
        did_one = done_one;
        sep = sep1;
        args = allargs;
    }
    if(multitype) {
        nice_printf(outfile, "%sMultitype *ret_val", sep);
        did_one = done_one;
        sep = sep1;
    }
    else if(ONEOF(std::get<2>(proctype), MSKCOMPLEX | MSKCHAR)) {
        if(!cxx)
        {
            s = xretslot[std::get<2>(proctype)]->user.ident;
            nice_printf(outfile, "%s%s *%s", sep, cpp2_type_decl(proctype, 0, false).c_str(),
                *s == '(' /*)*/ ? "r_v" : s);
            did_one = done_one;
            sep = sep1;
            if(std::get<2>(proctype) == TYCHAR)
                nice_printf(outfile, "%sftnlen ret_val_len", sep);
        }
    } /* if ONEOF proctype */
    for(; args; args = args->nextp) {
        Namep arg = (Namep)args->datap;

    /* Scalars are passed by reference, and arrays will have their lower bound
       adjusted, so nearly everything is printed with a star in front.  The
       exception is character lengths, which are passed by value. */

        if(arg) {
            int type = arg->vtype, class_ = arg->vclass;
            //arg->arginfo
            if(class_ == CLPROC)
                if(arg->vimpltype)
                    type = Castargs ? TYUNKNOWN : TYSUBR;
                else if(type == TYREAL && forcedouble && !Castargs)
                    type = TYDREAL;

            if(type == last_type && class_ == last_class && did_one)
                nice_printf(outfile, ", ");
            else
                if((is_ext = class_ == CLPROC) && Castargs)
                    nice_printf(outfile, "%s%s ", sep,
                        usedcasts[type] = casttypes[type]);
                else
                {
                    if(cxx){
                        nice_printf(outfile, "%s", sep);
                        write_cxx_type(outfile, arg, true, entryp->arglist, class_ == CLPARAM);
                    }
                    else{
                        nice_printf(outfile, "%s%s ", sep,
                            cpp_type_decl(arg, is_ext, false).c_str());
                    }
                }
            if(class_ == CLPROC)
                if(Castargs)
                    out_name(outfile, arg);
                else {
                    nice_printf(outfile, "(*");
                    out_name(outfile, arg);
                    nice_printf(outfile, ") %s", parens);
                }
            else {
                if(cxx)
                {
                    // already done in write_cxx_type
                    //if(arg->intent_in && !arg->intent_out){
                    //    nice_printf(outfile, "const ");
                    //}
                    //if(!arg->intent_value){
                    //    nice_printf(outfile, "& ");
                    //}
                }
                else
                {
                    nice_printf(outfile, "*");
                }
                out_name(outfile, arg);

                if(cxx && arg->is_optional && is_proto)
                {
                    nice_printf(outfile, " = boost::none");
                }
            }

            last_type = type;
            last_class = class_;
            did_one = done_one;
            sep = sep1;
        } /* if (arg) */
    } /* for args = entryp -> arglist */

    if(!cxx)
    {
        for(args = lengths; args; args = args->nextp)
            nice_printf(outfile, "%sftnlen %s", sep,
                new_arg_length((Namep)args->datap));
    }
    if(did_one)
        nice_printf(outfile, ";\n");
    else if(Ansi)
        nice_printf(outfile,
            /*((*/ sep != sep1 && Ansi == 1 ? "void)%s" : ")%s",
            finalnl);
} /* list_arg_types */

static void
write_formats(FILE *outfile)
 //FILE *outfile;
{
    register struct Labelblock *lp;
    int first = 1;
    char *fs;

    for(lp = labeltab; lp < highlabtab; ++lp)
        if(lp->fmtlabused) {
            if(first) {
                first = 0;
                nice_printf(outfile, "/* Format strings */\n");
            }
            nice_printf(outfile, "static char fmt_%ld[] = \"",
                lp->stateno);
            if(!(fs = lp->fmtstring))
                fs = "";
            nice_printf(outfile, "%s\";\n", fs);
        }
    if(!first)
        nice_printf(outfile, "\n");
}

static void
write_ioblocks(FILE *outfile)
 //FILE *outfile;
{
    register iob_data *L;
    register char *f, **s, *sep;

    nice_printf(outfile, "/* Fortran I/O blocks */\n");
    L = iob_list = (iob_data *)revchain((chainp)iob_list);
    do {
        nice_printf(outfile, "static %s %s = { ",
            L->type, L->name);
        sep = 0;
        for(s = L->fields; f = *s; s++) {
            if(sep)
                nice_printf(outfile, sep);
            sep = ", ";
            if(*f == '"') {	/* kludge */
                nice_printf(outfile, "\"");
                nice_printf(outfile, "%s\"", f + 1);
            }
            else
                nice_printf(outfile, "%s", f);
        }
        nice_printf(outfile, " };\n");
    } while(L = L->next);
    nice_printf(outfile, "\n\n");
}

static void
write_assigned_fmts(FILE *outfile)
 //FILE *outfile;
{
    register chainp cp;
    Namep np;
    int did_one = 0;

    cp = assigned_fmts = revchain(assigned_fmts);
    nice_printf(outfile, "/* Assigned format variables */\nchar ");
    do {
        np = (Namep)cp->datap;
        if(did_one)
            nice_printf(outfile, ", ");
        did_one = 1;
        nice_printf(outfile, "*%s_fmt", np->fvarname);
    } while(cp = cp->nextp);
    nice_printf(outfile, ";\n\n");
}

static char *
to_upper(char *s)
 //register char *s;
{
    static char buf[64];
    register char *t = buf;
    register int c;
    while(*t++ = (c = *s++) >= 'a' && c <= 'z' ? c + 'A' - 'a' : c);
    return buf;
}


/* This routine creates static structures representing a namelist.
   Declarations of the namelist and related structures are:

    struct Vardesc {
        char *name;
        char *addr;
        ftnlen *dims;	/* laid out as struct dimensions below *//*
        int  type;
        };
    typedef struct Vardesc Vardesc;

    struct Namelist {
        char *name;
        Vardesc **vars;
        int nvars;
        };

    struct dimensions
        {
        ftnlen numberofdimensions;
        ftnlen numberofelements
        ftnlen baseoffset;
        ftnlen span[numberofdimensions-1];
        };

   If dims is not null, then the corner element of the array is at
   addr.  However,  the element with subscripts (i1,...,in) is at
   addr + sizeoftype * (i1+span[0]*(i2+span[1]*...) - dimp->baseoffset)
*/

static void
write_namelists(chainp nmch, FILE *outfile)
 //chainp nmch;
 //FILE *outfile;
{
    Namep var;
    struct Hashentry *entry;
    struct Dimblock *dimp;
    int i, nd, type;
    char *comma, *name;
    register chainp q;
    register Namep v;
    extern int typeconv[];

    nice_printf(outfile, "/* Namelist stuff */\n\n");
    for(entry = hashtab; entry < lasthash; ++entry) {
        if(!(v = entry->varp) || !v->vnamelist)
            continue;
        type = v->vtype;
        name = v->cvarname;
        if(dimp = v->vdim) {
            nd = dimp->ndim;
            nice_printf(outfile,
                "static ftnlen %s_dims[] = { %d, %ld, %ld",
                name, nd,
                dimp->nelt->constblock.Const.ci,
                dimp->baseoffset->constblock.Const.ci);
            for(i = 0, --nd; i < nd; i++)
                nice_printf(outfile, ", %ld",
                    dimp->dims[i].dimsize->constblock.Const.ci);
            nice_printf(outfile, " };\n");
        }
        nice_printf(outfile, "static Vardesc %s_dv = { \"%s\", %s",
            name, to_upper(v->fvarname),
            type == TYCHAR ? ""
            : (dimp || oneof_stg(v, v->vstg,
            M(STGEQUIV) | M(STGCOMMON)))
            ? "(char *)" : "(char *)&");
        out_name(outfile, v);
        nice_printf(outfile, dimp ? ", %s_dims" : ", (ftnlen *)0", name);
        nice_printf(outfile, ", %ld };\n",
            type != TYCHAR ? (long)typeconv[type]
            : -v->vleng->constblock.Const.ci);
    }

    do {
        var = (Namep)nmch->datap;
        name = var->cvarname;
        nice_printf(outfile, "\nstatic Vardesc *%s_vl[] = ", name);
        comma = "{";
        i = 0;
        for(q = var->varxptr.namelist; q; q = q->nextp) {
            v = (Namep)q->datap;
            if(!v->vnamelist)
                continue;
            i++;
            nice_printf(outfile, "%s &%s_dv", comma, v->cvarname);
            comma = ",";
        }
        nice_printf(outfile, " };\n");
        nice_printf(outfile,
            "static Namelist %s = { \"%s\", %s_vl, %d };\n",
            name, to_upper(var->fvarname), name, i);
    } while(nmch = nmch->nextp);
    nice_printf(outfile, "\n");
}

/* fixextype tries to infer from usage in previous procedures
   the type of an external procedure declared
   external and passed as an argument but never typed or invoked.
 */

static int
fixexttype(Namep var)
 //Namep var;
{
    Extsym *e;
    int type, type1;

    type = var->vtype;
    e = &extsymtab[var->vardesc.varno];
    if((type1 = e->extype) && type == TYUNKNOWN)
        return var->vtype = type1;
    if(var->visused) {
        if(e->exused && type != type1)
            changedtype(var);
        e->exused = 1;
        e->extype = type;
    }
    return type;
}

static void
ref_defs(FILE *outfile, chainp refdefs)
//FILE *outfile; chainp refdefs;
{
    chainp cp;
    int eb, i, j, n;
    struct Dimblock *dimp;
//	long L;
    expptr b, vl;
    Namep var;
    char *amp, *comma;

    ind_printf(0, outfile, "\n");
    for(cp = refdefs = revchain(refdefs); cp; cp = cp->nextp) {
        var = (Namep)cp->datap;
        cp->datap = 0;
        amp = "_subscr";
        if(!(eb = var->vsubscrused)) {
            var->vrefused = 0;
            if(!ISCOMPLEX(var->vtype))
                amp = "_ref";
        }
        def_start(outfile, var->cvarname, amp, CNULL);
        dimp = var->vdim;
        vl = 0;
        comma = "(";
        amp = "";
        if(var->vtype == TYCHAR) {
            amp = "&";
            vl = var->vleng;
            if(ISCONST(vl) && vl->constblock.Const.ci == 1)
                vl = 0;
            nice_printf(outfile, "%sa_0", comma);
            comma = ",";
        }
        n = dimp->ndim;
        for(i = 1; i <= n; i++, comma = ",")
            nice_printf(outfile, "%sa_%d", comma, i);
        nice_printf(outfile, ") %s", amp);
        if(var->vsubscrused)
            var->vsubscrused = 0;
        else if(!ISCOMPLEX(var->vtype)) {
            out_name(outfile, var);
            nice_printf(outfile, "[%s", vl ? "(" : "");
        }
        for(j = 2; j < n; j++)
            nice_printf(outfile, "(");
        while(--i > 1) {
            nice_printf(outfile, "(a_%d)%s*", i, i == n ? "" : ")");
            expr_out(outfile, cpexpr(dimp->dims[i - 2].dimsize));
            nice_printf(outfile, " + ");
        }
        nice_printf(outfile, "a_1");
        if(var->vtype == TYCHAR) {
            if(vl) {
                nice_printf(outfile, ")*");
                expr_out(outfile, cpexpr(vl));
            }
            nice_printf(outfile, " + a_0");
        }
        if(var->vstg != STGARG && (b = dimp->baseoffset)) {
            b = cpexpr(b);
            if(var->vtype == TYCHAR)
                b = mkexpr(OPSTAR, cpexpr(var->vleng), b);
            nice_printf(outfile, " - ");
            expr_out(outfile, b);
        }
        if(ISCOMPLEX(var->vtype)) {
            ind_printf(0, outfile, "\n");
            def_start(outfile, var->cvarname, "_ref", CNULL);
            comma = "(";
            for(i = 1; i <= n; i++, comma = ",")
                nice_printf(outfile, "%sa_%d", comma, i);
            nice_printf(outfile, ") %s[%s_subscr",
                var->cvarname, var->cvarname);
            comma = "(";
            for(i = 1; i <= n; i++, comma = ",")
                nice_printf(outfile, "%sa_%d", comma, i);
            nice_printf(outfile, ")");
        }
        ind_printf(0, outfile, "]\n" + eb);
    }
    nice_printf(outfile, "\n");
    frchain(&refdefs);
}

void list_decls(FILE *outfile, bool is_module_head, chainp parameters)
//FILE *outfile;
{
    extern chainp used_builtins;
    extern struct Hashentry *hashtab;
    struct Hashentry *entry;
    int write_header = 1;
    int last_class = -1, last_stg = -1;
    Namep var;
    int Alias, Define, did_one, last_type, type;
    extern int def_equivs, useauto;
    extern chainp new_vars;	/* Compiler-generated locals */
    chainp namelists = 0, refdefs = 0;
    std::string ctype;
    int useauto1 = useauto && !saveall;
    long x;
    extern int hsize;



/* First write out the statically initialized data */

    if(initfile)
        list_init_data(&initfile, initfname, outfile);

    /* Next come formats */
    write_formats(outfile);

/* Now write out the system-generated identifiers */

    if(new_vars || nequiv) {
        chainp args, next_var, this_var;
        chainp nv[NTYPES0], nv1[NTYPES0];
        int i, j;
        Addrp Var;
        Namep arg;

        /* zap unused dimension variables */

        for(args = allargs; args; args = args->nextp) {
            arg = (Namep)args->datap;
            if(this_var = arg->vlastdim) {
                frexpr((tagptr)this_var->datap);
                this_var->datap = 0;
            }
        }

    /* sort new_vars by type, skipping entries just zapped */

        for(i = TYADDR; i < NTYPES0; i++)
            nv[i] = 0;
        for(this_var = new_vars; this_var; this_var = next_var) {
            next_var = this_var->nextp;
            if(Var = (Addrp)this_var->datap) {
                if(!(this_var->nextp = nv[j = Var->vtype]))
                    nv1[j] = this_var;
                nv[j] = this_var;
            }
            else {
                this_var->nextp = 0;
                frchain(&this_var);
            }
        }
        new_vars = 0;
        for(i = NTYPES0; --i >= TYADDR;)
            if(this_var = nv[i]) {
                nv1[i]->nextp = new_vars;
                new_vars = this_var;
            }

    /* write the declarations */

        did_one = 0;
        last_type = -1;

        for(this_var = new_vars; this_var; this_var = this_var->nextp) {
            Var = (Addrp)this_var->datap;

            if(Var == (Addrp)NULL)
                err("list_decls:  null variable");
            else if(Var->tag != TADDR)
                erri("list_decls:  bad tag on new variable '%d'",
                    Var->tag);

            type = nv_type(Var);
            if(Var->vstg == STGINIT
                || Var->uname_tag == UNAM_IDENT
                && *Var->user.ident == ' '
                && multitype)
                continue;
            if(!did_one)
                nice_printf(outfile, "/* System generated locals */\n");

            if(!cxx && last_type == type && did_one)
                nice_printf(outfile, ", ");
            else {
                if(did_one)
                    nice_printf(outfile, ";\n");
                if(cxx && Var->is_retval)
                {
                    write_cxx_type(outfile, std::get<0>(proctype), false, nullptr, false);
                }
                else
                {
                    nice_printf(outfile, "%s ",
                        cpp3_type_decl(type, Var->derived_type_name, Var->vclass == CLPROC, false).c_str());
                }
            } /* else */

    /* Character type is really a string type.  Put out a '*' for parameters
       with unknown length and functions returning character */

            if(!cxx && Var->vtype == TYCHAR && (!ISICON((Var->vleng))
                || Var->vclass == CLPROC))
                nice_printf(outfile, "*");

            write_nv_ident(outfile, (Addrp)this_var->datap);
            if(!cxx && Var->vtype == TYCHAR && Var->vclass != CLPROC &&
                ISICON((Var->vleng))
                && (i = Var->vleng->constblock.Const.ci) > 0)
                nice_printf(outfile, "[%d]", i);

            did_one = 1;
            last_type = nv_type(Var);
        } /* for this_var */

    /* Handle the uninitialized equivalences */

        do_uninit_equivs(outfile, &did_one);

        if(did_one)
            nice_printf(outfile, ";\n\n");
    } /* if new_vars */

/* Write out builtin declarations */

    if(!cxx && used_builtins) {
        chainp cp;
        Extsym *es;

        last_type = -1;
        did_one = 0;

        nice_printf(outfile, "/* Builtin functions */");

        for(cp = used_builtins; cp; cp = cp->nextp) {
            Addrp e = (Addrp)cp->datap;

            switch(type = e->vtype) {
            case TYDREAL:
            case TYREAL:
                /* if (forcedouble || e->dbl_builtin) */
                /* libF77 currently assumes everything double */
                type = TYDREAL;
                ctype = "double";
                break;
            case TYCOMPLEX:
            case TYDCOMPLEX:
                type = TYVOID;
                /* no break */
            default:
                ctype = c_type_decl(type, 0, false);
            }

            if(did_one && last_type == type)
                nice_printf(outfile, ", ");
            else
                nice_printf(outfile, "%s\n%s ", did_one ? ";" : "", ctype.c_str());

            extern_out(outfile, es = &extsymtab[e->memno]);
            proto(outfile, es->arginfo, es->fextname);
            last_type = type;
            did_one = 1;
        } /* for cp = used_builtins */

        nice_printf(outfile, ";\n\n");
    } /* if used_builtins */

    last_type = -1;

    std::vector<Namep> names;
    for(entry = hashtab; entry < lasthash; ++entry) {
        var = entry->varp;

        if(var) {
            names.push_back(var);
        }
    }

    if(cxx)
    {
        std::sort(names.begin(), names.end(), [](auto l, auto r){return l->hash_index < r->hash_index; });
    }
    auto types_out = [&](bool derived)
    {
        for(auto var_: names) {
            var = var_;
            {
                int procclass = var->vprocclass;
                char *comment = NULL;
                int stg = var->vstg;
                int class_ = var->vclass;
                type = var->vtype;

                if((type == TY_DERIVED) ^ derived)
                {
                    continue;
                }

                if(var->vrefused)
                    refdefs = mkchain((char *)var, refdefs);
                if(var->vsubscrused)
                    if(ISCOMPLEX(var->vtype))
                        var->vsubscrused = 0;
                    else
                        refdefs = mkchain((char *)var, refdefs);
                if(ONEOF(stg, M(STGARG) | M(STGLENG) | M(STGINIT)))
                    continue;

                if(useauto1 && stg == STGBSS && !var->vsave)
                    stg = STGAUTO;

                bool ignore_stgunknown = false;
                switch(class_) {
                case CLVAR:
                    break;
                case CLPROC:
                    switch(procclass) {
                    case PTHISPROC:
                        extsymtab[var->vardesc.varno].extype = type;
                        continue;
                    case PSTFUNCT:
                    case PINTRINSIC:
                        continue;
                    case PUNKNOWN:
                        err("list_decls:  unknown procedure class_");
                        continue;
                    case PEXTERNAL:
                        if(stg == STGUNKNOWN) {
                            warn1(
                                "%.64s declared EXTERNAL but never used.",
                                var->fvarname);
                            /* to retain names declared EXTERNAL */
                            /* but not referenced, change
                            /* "continue" to "stg = STGEXT" */
                            continue;
                        }
                        else
                            type = fixexttype(var);
                    }
                    break;
                case CLUNKNOWN:
                    /* declared but never used */
                    if(!unused_vars)
                    {
                        continue;
                    }
                    ignore_stgunknown = true;
                    break;
                case CLPARAM:
                    if(!symbolic_params)
                    {
                        continue;
                    }
                    ignore_stgunknown = true;
                    break;
                case CLNAMELIST:
                    if(var->visused)
                        namelists = mkchain((char *)var, namelists);
                    continue;
                default:
                    erri("list_decls:  can't handle class_ '%d' yet",
                        class_);
                    Fatal(var->fvarname);
                    continue;
                } /* switch */

                  /* Might be equivalenced to a common.  If not, don't process */
                if(stg == STGCOMMON && !var->vcommequiv)
                    continue;

                if(!is_module_head && cxx && 
                    (stg == STGEXT || (stg == STGUNKNOWN && class_ != CLPARAM))
                    )
                {
                    continue;
                }
                if(cxx && stg == STGUNKNOWN && var->vtype == TYUNKNOWN)
                {
                    continue;
                }

                if(cxx && var->is_invoked && !var->vdim && var->vtype != TYCHAR)
                {
                    fprintf(diagfile, "REMOVED: external symbol %s\n", var->fvarname);
                    fflush(diagfile);
                    continue;
                }


                /* Only write the header if system-generated locals, builtins, or
                uninitialized equivs were already output */

                if(write_header == 1 && (new_vars || nequiv || used_builtins)
                    && oneof_stg(var, stg,
                    M(STGBSS) | M(STGEXT) | M(STGAUTO) | M(STGCOMMON) | M(STGEQUIV))) {
                    nice_printf(outfile, "/* Local variables */\n");
                    write_header = 2;
                }

                bool needs_dynamic_alloc = false;
                bool is_result_var = false;
                Alias = oneof_stg(var, stg, M(STGEQUIV) | M(STGCOMMON));
                if(Define = (Alias && def_equivs)) {
                    if(!write_header)
                        nice_printf(outfile, ";\n");
                    def_start(outfile, var->cvarname, CNULL, "(");
                    goto Alias1;
                }
                else
                    if(!no_var_pooling && type == last_type && class_ == last_class &&
                        stg == last_stg && !write_header
                        &&
                        !(symbolic_params && class_ == CLPARAM)
                        )
                        nice_printf(outfile, ", ");
                    else {
                        if(!write_header && ONEOF(stg, M(STGBSS) |
                            M(STGEXT) | M(STGAUTO) | M(STGEQUIV) | M(STGCOMMON) |
                            (ignore_stgunknown ? M(STGUNKNOWN) : 0)
                            ))
                        {
                            nice_printf(outfile, ";\n");
                        }

                        switch(stg) {
                        case STGARG:
                        case STGLENG:
                            /* Part of the argument list, don't write them out
                            again */
                            continue;	    /* Go back to top of the loop */
                        case STGBSS:
                        case STGEQUIV:
                        case STGCOMMON:
                            nice_printf(outfile, "static ");
                            break;
                        case STGEXT:
                            nice_printf(outfile, "extern ");
                            break;
                        case STGAUTO:
                            break;
                        case STGINIT:
                        case STGUNKNOWN:
                            if(ignore_stgunknown)
                            {
                                break;
                            }
                            /* Don't want to touch the initialized data, that will
                            be handled elsewhere.  Unknown data have
                            already been complained about, so skip them */
                            continue;
                        default:
                            erri("list_decls:  can't handle storage class_ %d",
                                stg);
                            continue;
                        } /* switch */

                        if(type == TYCHAR && halign && class_ != CLPROC
                            && ISICON(var->vleng)) {
                            nice_printf(outfile, "struct { %s fill; char val",
                                halign);
                            x = wr_char_len(outfile, var->vdim,
                                var->vleng->constblock.Const.ci, 1);
                            if(x %= hsize)
                                nice_printf(outfile, "; char fill2[%ld]",
                                    hsize - x);
                            nice_printf(outfile, "; } %s_st;\n", var->cvarname);
                            def_start(outfile, var->cvarname, CNULL, var->cvarname);
                            ind_printf(0, outfile, "_st.val\n");
                            last_type = -1;
                            write_header = 2;
                            continue;
                        }

                        if(class_ == CLPARAM)
                        {
                            if(var->vdim)
                            {
                                if(is_module_head)
                                {
                                    // constexpr only allowed for literal types
                                    //nice_printf(outfile, "FT_SELECT_ANY FT_STORAGE FT_CONST /*constexpr*/ ");
                                    nice_printf(outfile, "static constexpr ");
                                }
                                else
                                {
                                    // constexpr only allowed for literal types
                                    //nice_printf(outfile, "static FT_CONST /*constexpr*/ ");
                                    nice_printf(outfile, "static constexpr ");
                                }
                            }
                            else
                            {
                                nice_printf(outfile, "static constexpr ");
                            }
                        }
                        else if(is_module_head)
                        {
                            nice_printf(outfile, "__declspec(selectany) ");
                        }

                        if(cxx)
                        {
                            if(!is_module_head && !entries->alt_result.empty()
                                && strcmp(entries->alt_result.c_str(), var->fvarname) == 0) {
                                is_result_var = true;
                                needs_dynamic_alloc = false;
                                nice_printf(outfile, "auto& ");
                            } else {
                                needs_dynamic_alloc = write_cxx_type(outfile, var, false, parameters, class_ == CLPARAM);
                            }
                        }
                        else
                        {
                            nice_printf(outfile, "%s ",
                                cpp_type_decl(var, class_ == CLPROC, false).c_str());
                        }


                    } /* else */

                      /* Character type is really a string type.  Put out a '*' for variable
                      length strings, and also for equivalences */

                    if(type == TYCHAR && class_ != CLPROC
                        && (!var->vleng || !ISICON(var->vleng))
                        || oneof_stg(var, stg, M(STGEQUIV) | M(STGCOMMON)))
                    {
                        nice_printf(outfile, "*%s", var->cvarname);
                    }
                    else 
                    {
                        nice_printf(outfile, "%s", var->cvarname);
                        if(class_ == CLPROC) 
                        {
                            Argtypes *at;
                            if(!(at = var->arginfo)
                                && var->vprocclass == PEXTERNAL)
                                at = extsymtab[var->vardesc.varno].arginfo;
                            proto(outfile, at, var->fvarname);
                        }
                        else if(!cxx && type == TYCHAR && ISICON((var->vleng)))
                        {
                            wr_char_len(outfile, var->vdim,
                                (int)var->vleng->constblock.Const.ci, 0);
                        }
                        else if(!cxx && var->vdim &&
                            !oneof_stg(var, stg, M(STGEQUIV) | M(STGCOMMON)))
                        {
                            comment = wr_ardecls(outfile, var->vdim, 1L);
                        }
                    }

                    if(class_ == CLPARAM)
                    {
                        if(cxx)
                        {
                            Paramblock* param = (Paramblock*)var;
                            if(var->vdim)//  param->paramval && param->paramval->nextp)
                            {
                                // two or more...
                                nice_printf(outfile, "= { ");
                                for(auto e_ = param->paramval; e_; e_ = e_->nextp)
                                {
                                    auto e = (expptr)e_->datap;

                                    expr_out(outfile, cpexpr(e));

                                    if(e_->nextp){
                                        nice_printf(outfile, ", ");
                                    }
                                    else {
                                        nice_printf(outfile, " }");
                                    }
                                }
                            }
                            else
                            {
                                // single value initialization
                                nice_printf(outfile, "= ");
                                for(auto e_ = param->paramval; e_; e_ = e_->nextp)
                                {
                                    auto e = (expptr)e_->datap;

                                    expr_out(outfile, cpexpr(e));

                                    if(e_->nextp){
                                        nice_printf(outfile, ", ");
                                    }
                                }
                            }
                        }
                        else
                        {
                            nice_printf(outfile, "= ");
                            Paramblock* param = (Paramblock*)var;
                            for(auto e_ = param->paramval; e_; e_ = e_->nextp)
                            {
                                auto e = (expptr)e_->datap;

                                expr_out(outfile, cpexpr(e));
                            }
                        }
                    }
                    else
                    {
                        if(is_result_var) {
                            nice_printf(outfile, " = ret_val");
                        } else if(needs_dynamic_alloc)
                        {
                            if(var->vdim){
                                nice_printf(outfile, "{ft::dyn_alloc_tag{}");

                                bool needs_sizing = false;
                                auto dimp = var->vdim;
                                for(int i = 0; i < dimp->ndim; i++) {

                                    if(!dimp->dims[i].ub)
                                    {
                                        assert(!needs_sizing);
                                        needs_sizing = false;
                                        break;
                                    }
                                    else
                                    {
                                        nice_printf(outfile, ", ft::dyn_alloc{");
                                        if(dimp->dims[i].lb)
                                        {
                                            expr_out(outfile, cpexpr(dimp->dims[i].lb));
                                            nice_printf(outfile, ", ");
                                        }
                                        assert(dimp->dims[i].ub);
                                        expr_out(outfile, cpexpr(dimp->dims[i].ub));
                                        nice_printf(outfile, "}");
                                    }
                                }
                                nice_printf(outfile, "}");
                            }
                        }
                    }


                    if(comment)
                        nice_printf(outfile, "%s", comment);
                Alias1:
                    if(Alias) {
                        char *amp, *lp, *name, *rp;
                        ftnint voff = var->voffset;
                        int et0, expr_type, k;
                        Extsym *E;
                        struct Equivblock *eb;
                        char buf[16];

                        /* We DON'T want to use oneof_stg here, because we need to distinguish
                        between them */

                        if(stg == STGEQUIV) {
                            name = equiv_name(k = var->vardesc.varno, CNULL);
                            eb = eqvclass + k;
                            if(eb->eqvinit) {
                                amp = "&";
                                et0 = TYERROR;
                            }
                            else {
                                amp = "";
                                et0 = eb->eqvtype;
                            }
                            expr_type = et0;
                        }
                        else {
                            E = &extsymtab[var->vardesc.varno];
                            sprintf(name = buf, "%s%d", E->cextname, E->curno);
                            expr_type = type;
                            et0 = -1;
                            amp = "&";
                        } /* else */

                        if(!Define)
                            nice_printf(outfile, " = ");
                        if(voff) {
                            k = typesize[type];
                            switch((int)(voff % k)) {
                            case 0:
                                voff /= k;
                                expr_type = type;
                                break;
                            case SZSHORT:
                            case SZSHORT + SZLONG:
                                expr_type = TYSHORT;
                                voff /= SZSHORT;
                                break;
                            case SZLONG:
                                expr_type = TYLONG;
                                voff /= SZLONG;
                                break;
                            default:
                                expr_type = TYCHAR;
                            }
                        }

                        if(expr_type == type) {
                            lp = rp = "";
                            if(et0 == -1 && !voff)
                                goto cast;
                        }
                        else {
                            lp = "(";
                            rp = ")";
                        cast:
                            nice_printf(outfile, "(%s *)", cpp_type_decl(var, 0, false).c_str());
                        }

                        /* Now worry about computing the offset */

                        if(voff) {
                            if(expr_type == et0)
                                nice_printf(outfile, "%s%s + %ld%s",
                                    lp, name, voff, rp);
                            else
                                nice_printf(outfile, "%s(%s *)%s%s + %ld%s", lp,
                                    c_type_decl(expr_type, 0, false).c_str(), amp,
                                    name, voff, rp);
                        }
                        else
                            nice_printf(outfile, "%s%s", amp, name);
                        /* Always put these at the end of the line */
                        last_type = last_class = last_stg = -1;
                        write_header = 0;
                        if(Define) {
                            ind_printf(0, outfile, ")\n");
                            write_header = 2;
                        }
                        continue;
                    }
                    write_header = 0;
                    last_type = type;
                    last_class = class_;
                    last_stg = stg;
            } /* if (var) */
        } /* for (entry = hashtab */
    };

    types_out(false);

    if(!write_header)
        nice_printf(outfile, ";\n\n");
    else if(write_header == 2)
        nice_printf(outfile, "\n");

    /* First write out the typedefs */
    for(auto&& t : new_types)
    {
        if(t.name_super.empty())
        {
            nice_printf(outfile, "struct  %s {\n", t.name.c_str());
        }
        else
        {
            nice_printf(outfile, "struct  %s : %s {\n", t.name.c_str(), t.name_super.c_str());
        }
        next_tab(outfile);


        for(auto&& n : t.members)
        {
            do_struct_member(n, infile, outfile);
        }

        prev_tab(outfile);
        nice_printf(outfile, "};\n");
    }

    write_header = 1;

    types_out(true);

    if(!write_header)
        nice_printf(outfile, ";\n\n");
    else if(write_header == 2)
        nice_printf(outfile, "\n");

    /* Next, namelists, which may reference equivs */

    if(namelists) {
        write_namelists(namelists = revchain(namelists), outfile);
        frchain(&namelists);
    }

/* Finally, ioblocks (which may reference equivs and namelists) */
    if(iob_list)
        write_ioblocks(outfile);
    if(assigned_fmts)
        write_assigned_fmts(outfile);

    if(refdefs)
        ref_defs(outfile, refdefs);

} /* list_decls */

void do_uninit_equivs(FILE *outfile, int *did_one)
//FILE *outfile;
//int *did_one;
{
    extern int nequiv;
    struct Equivblock *eqv, *lasteqv = eqvclass + nequiv;
    int k, last_type = -1, t;

    for(eqv = eqvclass; eqv < lasteqv; eqv++)
        if(!eqv->eqvinit && eqv->eqvtop != eqv->eqvbottom) {
            if(!*did_one)
                nice_printf(outfile, "/* System generated locals */\n");
            t = eqv->eqvtype;
            if(last_type == t)
                nice_printf(outfile, ", ");
            else {
                if(*did_one)
                    nice_printf(outfile, ";\n");
                nice_printf(outfile, "static %s ", c_type_decl(t, 0, false).c_str());
                k = typesize[t];
            } /* else */
            nice_printf(outfile, "%s", equiv_name((int)(eqv - eqvclass), CNULL));
            nice_printf(outfile, "[%ld]",
                (eqv->eqvtop - eqv->eqvbottom + k - 1) / k);
            last_type = t;
            *did_one = 1;
        } /* if !eqv -> eqvinit */
} /* do_uninit_equivs */


/* wr_ardecls -- Writes the brackets and size for an array
   declaration.  Because of the inner workings of the compiler,
   multi-dimensional arrays get mapped directly into a one-dimensional
   array, so we have to compute the size of the array here.  When the
   dimension is greater than 1, a string comment about the original size
   is returned */

char *wr_ardecls(FILE *outfile, struct Dimblock *dimp, long size)
//FILE *outfile;
//struct Dimblock *dimp;
//long size;
{
    int i, k;
    static char buf[1000];

    if(dimp == (struct Dimblock *) NULL)
        return NULL;

    sprintf(buf, "\t/* was ");	/* would like to say  k = sprintf(...), but */
    k = strlen(buf);		/* BSD doesn't return char transmitted count */

    for(i = 0; i < dimp->ndim; i++) {
        expptr this_size = dimp->dims[i].dimsize;

        if(!symbolic_params && !ISICON(this_size))
            err("wr_ardecls:  nonconstant array size");
        else {
            size *= this_size->constblock.Const.ci;
            sprintf(buf + k, "[%ld]", this_size->constblock.Const.ci);
            k += strlen(buf + k);	/* BSD prevents combining this with prev stmt */
        } /* else */
    } /* for i = 0 */

    nice_printf(outfile, "[%ld]", size);
    strcat(buf + k, " */");

    return (i > 1) ? buf : NULL;
} /* wr_ardecls */

std::string get_op_string(int op)
{
    switch(op)
    {
    case OPPLUS: return " + ";
    case OPMINUS: return " - ";
    case OPSTAR: return " * ";

    default:
        {
            std::stringstream ss;
            ss << op;
            // test both
            return "op<" + ss.str() + ">";
        }
        break;
    }
}

std::string to_string(expptr test)
{
    expptr tester = test;
    switch(tester->tag)
    {
    case TCONST:
        {
            if(ISICON(tester))
            {
                std::stringstream ss;
                ss << tester->constblock.Const.ci;
                return ss.str();
            }
        }
        break;
    case TPRIM: tester = (expptr)tester->primblock.namep;   break;
    case TNAME: break;
    case TEXPR: 
        {
            switch(tester->exprblock.opcode)
            {
            case OPMEMBER:
            case OPMEMBER_OF_ALLOCATABLE:
            {
                    std::string result = to_string(tester->exprblock.leftp) + "%"
                        +
                        to_string(tester->exprblock.rightp)
                        ;
                    return result;
                }
                break;

            default:
                {
                    // test both
                    return 
                        to_string(tester->exprblock.leftp) + " " + get_op_string(tester->exprblock.opcode) + " "
                        +
                        to_string(tester->exprblock.rightp)
                        ;
                }
                break;
            }
        }        
        break;

    default: return "";
    }

    //if(tester == (expptr)parameter)
    //{
    //    names.push_back(parameter->cvarname);
    //    return true;
    //}
    return ((Namep)tester)->cvarname;
}


bool is_function_parameter(Namep parameter, expptr test, std::vector<std::string>& names)
{
    if(!test || !parameter)
    {
        return false;
    }
    expptr tester = test;
    switch(tester->tag)
    {
    case TPRIM: tester = (expptr)tester->primblock.namep;   break;
    case TNAME: break;
    case TEXPR: 
        {
            switch(tester->exprblock.opcode)
            {
            case OPMEMBER:
            case OPMEMBER_OF_ALLOCATABLE:
            {
                    bool result = is_function_parameter(parameter, tester->exprblock.leftp, names);
                    if(result)
                    {
                        names.back() += "%" + to_string(tester->exprblock.rightp);
                    }
                    return result;
                }
                break;

            default:
                {
                    // test both
                    bool result =
                        is_function_parameter(parameter, tester->exprblock.leftp, names)
                        ||
                        is_function_parameter(parameter, tester->exprblock.rightp, names)
                        ;

                        if(result)
                        {
                            names.back() = to_string(tester);
                        }
                    return result;
                    ;
                }
                break;
            }
        }        
        break;

    case TLIST:
        {
            for(auto p = tester->listblock.listp;p;p=p->nextp) {
                if(is_function_parameter(parameter, (expptr)p->datap, names))
                {
                    return true;
                }
            }

        }
        break;

    default: return false;
    }

    if(tester == (expptr)parameter)
    {
        names.push_back(parameter->cvarname);
        return true;
    }
    return false;
}


bool is_function_parameter(chainp parameters, expptr lb, expptr ub, std::vector<std::string>& names)
{
    bool result = false;
    if(lb)
    {
        for(auto args = parameters; args; args = args->nextp) {
            Namep arg = (Namep)args->datap;
            if(arg)
            {
                if(is_function_parameter(arg, lb, names))
                {
                    result = true;
                    break;
                }
            }
        }
    }
    if(ub)
    {
        for(auto args = parameters; args; args = args->nextp) {
            Namep arg = (Namep)args->datap;
            if(arg)
            {
                if(is_function_parameter(arg, ub, names))
                {
                    result = true;
                    break;
                }
            }
        }
    }
    return result;
}

bool write_cxx_type(FILE *outfile, Namep var, bool add_const_ref, chainp parameters, bool is_const_param)
{
    bool at_least_one_dynamic = false;

    if(var->vdim){

        std::string type_name;
        if(var->is_optional)
        {
            type_name += "ft::optional<";
        }
        type_name += "ft::fort_array";
        if(var->is_allocatable)
        {
            type_name += "_alloc";
        }
        switch(var->vdim->ndim)
        {
        case 1: break;
        case 2:
            type_name += "_2";
            break;
        case 3:
            type_name += "_3";
            break;

        default: 
            fprintf(diagfile, "FT::FORT_ARRAY: dimensions: %d\n", var->vdim->ndim);
            type_name += "_???";
            break;
            //    assert(false);
        }


        if(add_const_ref)
        {
            bool underscore = true;
            if(var->intent_in && !var->intent_out){
                type_name += "_c";
                underscore = false;
            }
            if(!var->intent_value){
                if(underscore){
                    type_name += "_";
                }
                type_name += "r";
            }
        }

        nice_printf(outfile, "%s<%s",
            type_name.c_str(),
            cpp_type_decl(var, 0, is_const_param).c_str());

        auto dimp = var->vdim;

        // check if there is a dynamic dimension
        for(int i = 0; i < dimp->ndim; i++) {
            if(!dimp->dims[i].ub)
            {
                //// it's a star *
                //if(!dimp->dims[i].lb)
                //{
                //    nice_printf(outfile, "ft::dyn_dim /* * */");
                //}
                //else
                //{
                //    nice_printf(outfile, "ft::dyn_dim /* ");
                //    expr_out(outfile, cpexpr(dimp->dims[i].lb));
                //    nice_printf(outfile, ", * */");
                //}
            }
            else
            {
                bool maybe_dynamic = var->vclass != CLPARAM
                    &&
                    (!is_const(dimp->dims[i].lb) || !is_const(dimp->dims[i].ub));

                std::vector<std::string> param_names;
                bool dynamic = maybe_dynamic
                    &&
                    parameters
                    &&
                    is_function_parameter(parameters, dimp->dims[i].lb, dimp->dims[i].ub, param_names);

                if(dynamic){
                    at_least_one_dynamic = true;
                    break;
                }
            }
        }


        for(int i = 0; i < dimp->ndim; i++) {
            nice_printf(outfile, ", ");

            if(!dimp->dims[i].ub)
            {
                // it's a star *
                if(!dimp->dims[i].lb)
                {
                    nice_printf(outfile, "ft::dyn_dim /* * */");
                }
                else
                {
                    nice_printf(outfile, "ft::dyn_dim /* ");
                    expr_out(outfile, cpexpr(dimp->dims[i].lb));
                    nice_printf(outfile, ", * */");
                }
            }
            else
            {
                bool maybe_dynamic = var->vclass != CLPARAM
                    &&
                    (!is_const(dimp->dims[i].lb) || !is_const(dimp->dims[i].ub));

                std::vector<std::string> param_names;

                // just evaluated to get string
                bool dynamic = maybe_dynamic
                    &&
                    parameters
                    &&
                    is_function_parameter(parameters, dimp->dims[i].lb, dimp->dims[i].ub, param_names);

                if(at_least_one_dynamic){
                    nice_printf(outfile, "ft::dyn /* dynamic: ");
                    bool tail = false;
                    for(auto&& n : param_names)
                    {
                        if(tail)
                        {
                            nice_printf(outfile, ", ");
                        }
                        else
                        {
                            tail = true;
                        }
                        nice_printf(outfile, "%s", n.c_str());
                    }
                    nice_printf(outfile, " */");
                }
                else 
                {
                    if(maybe_dynamic){
                        nice_printf(outfile, "/* maybe dynamic */ ");
                    }

                    if(dimp->dims[i].lb){
                        //if(!dynamic){
                        nice_printf(outfile, "ft::bs<");
                        //}
                        expr_out(outfile, cpexpr(dimp->dims[i].lb));
                        nice_printf(outfile, ", ");
                        expr_out(outfile, cpexpr(dimp->dims[i].ub));
                        //if(!dynamic){
                        nice_printf(outfile, ">");
                        //}
                    }
                    else{
                        //if(!dynamic){
                        nice_printf(outfile, "ft::bs<1, ");
                        //}
                        expr_out(outfile, cpexpr(dimp->dims[i].ub));
                        //if(!dynamic){
                        nice_printf(outfile, ">");
                        //}
                    }
                }

            }
        }
        if(var->is_optional)
        {
            nice_printf(outfile, ">");
        }
        nice_printf(outfile, "> ");
    }
    else
    {
        if (var->is_allocatable)
        {
            nice_printf(outfile, "ft::allocatable<");
        }
        if (var->is_optional)
        {
            nice_printf(outfile, "ft::optional<");
        }
        nice_printf(outfile, "%s",
            cpp_type_decl(var, 0, is_const_param).c_str());

        if(add_const_ref)
        {
            if(var->intent_in && !var->intent_out){
                nice_printf(outfile, " const");
            }
            if(!var->intent_value){
                nice_printf(outfile, " &");
            }
        }
        if(var->is_optional)
        {
            nice_printf(outfile, ">");
        }
        if (var->is_allocatable)
        {
            nice_printf(outfile, ">");
        }
        nice_printf(outfile, " ");

    }


    return at_least_one_dynamic;
}



/* ----------------------------------------------------------------------

    The following routines read from the p1 intermediate file.  If
   that format changes, only these routines need be changed

   ---------------------------------------------------------------------- */

static int get_p1_token(FILE *infile)
//FILE *infile;
{
    int token = P1_UNKNOWN;

/* NOT PORTABLE!! */

    if(fscanf(infile, "%d", &token) == EOF)
        return P1_EOF;

    /* Skip over the ": " */

    if(getc(infile) != '\n')
        getc(infile);

    return token;
} /* get_p1_token */



/* Returns a (null terminated) string from the input file */

static int p1gets(FILE *fp, char *str, int size)
//FILE *fp;
//char *str;
//int size;
{
    char *fgets();
    char c;

    if(str == NULL)
        return 0;

    if((c = getc(fp)) != ' ')
        ungetc(c, fp);

    if(fgets(str, size, fp)) {
        int length;

        str[size - 1] = '\0';
        length = strlen(str);

    /* Get rid of the newline */

        if(str[length - 1] == '\n')
            str[length - 1] = '\0';
        return 1;

    }
    else if(feof(fp))
        return EOF;
    else
        return 0;
} /* p1gets */


static int p1get_const(FILE *infile, int type, struct Constblock **resultp)
//FILE *infile;
//int type;
//struct Constblock **resultp;
{
    int status;
    struct Constblock *result;

    if(type != TYCHAR) {
        *resultp = result = ALLOC(Constblock);
        result->tag = TCONST;
        result->vtype = type;
    }

    switch(type) {
    case TYINT1:
    case TYSHORT:
    case TYLONG:
    case TYLOGICAL:
#ifdef TYQUAD
    case TYQUAD:
#endif
    case TYLOGICAL1:
    case TYLOGICAL2:
        status = p1getd(infile, &(result->Const.ci));
        break;
    case TYREAL:
    case TYDREAL:
        status = p1getf(infile, &result->Const.cds[0]);
        result->vstg = 1;
        break;
    case TYCOMPLEX:
    case TYDCOMPLEX:
        status = p1getf(infile, &result->Const.cds[0]);
        if(status && status != EOF)
            status = p1getf(infile, &result->Const.cds[1]);
        result->vstg = 1;
        break;
    case TYCHAR:
        status = fscanf(infile, "%lx", (unsigned long*)resultp);
        break;
    default:
        erri("p1get_const:  bad constant type '%d'", type);
        status = 0;
        break;
    } /* switch */

    return status;
} /* p1get_const */

static int p1getd(FILE *infile, long *result)
//FILE *infile;
//long *result;
{
    return fscanf(infile, "%ld", result);
} /* p1getd */

static int
p1getf(FILE *infile, char **result)
 //FILE *infile;
 //char **result;
{

    char buf[1324];
    register int k;

    k = fscanf(infile, "%s", buf);
    if(k < 1)
        k = EOF;
    else
        strcpy(*result = mem(strlen(buf) + 1, 0), buf);
    return k;
}

static int p1getn(FILE *infile, int count, char **result)
//FILE *infile;
//int count;
//char **result;
{

    char *bufptr;

    bufptr = (char *)ckalloc(count);

    if(result)
        *result = bufptr;

    for(; !feof(infile) && count > 0; count--)
        *bufptr++ = getc(infile);

    return feof(infile) ? EOF : 1;
} /* p1getn */

static void
proto(FILE *outfile, Argtypes *at, char *fname)
 //FILE *outfile;
 //Argtypes *at;
 //char *fname;
{
    int i, j, k, n;
    char *comma;
    Atype *atypes;
    Namep np;
    chainp cp;

    if(at) {
        /* Correct types that we learn on the fly, e.g.
            subroutine gotcha(foo)
            external foo
            call zap(...,foo,...)
            call foo(...)
        */
        atypes = at->atypes;
        n = at->defined ? at->dnargs : at->nargs;
        for(i = 0; i++ < n; atypes++) {
            if(!(cp = atypes->cp))
                continue;
            j = atypes->type;
            do {
                np = (Namep)cp->datap;
                k = np->vtype;
                if(np->vclass == CLPROC) {
                    if(!np->vimpltype && k)
                        k += 200;
                    else {
                        if(j >= 300)
                            j = TYUNKNOWN + 200;
                        continue;
                    }
                }
                if(j == k)
                    continue;
                if(j >= 300
                    || j == 200 && k >= 200)
                    j = k;
                else {
                    if(at->nargs >= 0)
                        bad_atypes(at, fname, i, j, k, "", " and");
                    goto break2;
                }
            } while(cp = cp->nextp);
            atypes->type = j;
            frchain(&atypes->cp);
        }
    }
break2:
    if(parens) {
        nice_printf(outfile, parens);
        return;
    }

    if(!at || (n = at->defined ? at->dnargs : at->nargs) < 0) {
        nice_printf(outfile, Ansi == 1 ? "()" : "(...)");
        return;
    }

    if(n == 0) {
        nice_printf(outfile, Ansi == 1 ? "(void)" : "()");
        return;
    }

    atypes = at->atypes;
    nice_printf(outfile, "(");
    comma = "";
    for(; --n >= 0; atypes++) {
        k = atypes->type;
        if(k == TYADDR)
            nice_printf(outfile, "%schar **", comma);
        else if(k >= 200) {
            k -= 200;
            nice_printf(outfile, "%s%s", comma,
                usedcasts[k] = casttypes[k]);
        }
        else if(k >= 100)
            nice_printf(outfile,
                k == TYCHAR + 100 ? "%s%s *" : "%s%s",
                comma, c_type_decl(k - 100, 0, false).c_str());
        else
            nice_printf(outfile, "%s%s *", comma,
                c_type_decl(k, 0, false).c_str());
        comma = ", ";
    }
    nice_printf(outfile, ")");
}

void
protowrite(FILE *protofile, proctype_t type, char *name, struct Entrypoint *e, chainp lengths)
 //FILE *protofile;
 //char *name;
 //struct Entrypoint *e;
 //chainp lengths;
{
    extern char used_rets[];
    int asave;

    if(!(asave = Ansi))
        Castargs = Ansi = 1;

    bool do_export = false;
    std::string test_name = name;
    if(test_name.find("_proxy") != std::string::npos)
    {
        do_export = true;
    }

    char* exported_names[] = {
        "rauchgasschnittstelle_internal_inout"
    };
    for(auto&& n : exported_names)
    {
        if(n == test_name)
        {
            do_export = true;
            break;
        }
    }
    if(do_export)
    {
        nice_printf(protofile, "__declspec(dllexport) ");
    }

    write_cxx_type(protofile, std::get<0>(type), false, nullptr, false);
    nice_printf(protofile, "%s", name);

    //if(type.first == TY_DERIVED)
    //{
    //    nice_printf(protofile, "%s %s", type.second.c_str(), name);
    //}
    //else
    //{
    //    nice_printf(protofile, "%s %s", protorettypes[type.first], name);
    //}
    list_arg_types(protofile, e, lengths, 0, ";\n", true);
    used_rets[std::get<2>(type)] = 1;
    if(!(Ansi = asave))
        Castargs = 0;
}

static void
do_p1_1while(FILE *outfile)
 //FILE *outfile;
{
    if(*wh_next) {
        nice_printf(outfile,
            "for(;;) { /* while(complicated condition) */\n" /*}*/);
        next_tab(outfile);
    }
    else
        nice_printf(outfile, "while(" /*)*/);
}

static void
do_p1_2while(FILE *infile, FILE *outfile)
 //FILE *infile, *outfile;
{
    expptr test;

    test = do_format(infile, outfile);
    if(*wh_next)
        nice_printf(outfile, "if (!(");
    expr_out(outfile, test);
    if(*wh_next++)
        nice_printf(outfile, "))\n\tbreak;\n");
    else {
        nice_printf(outfile, /*(*/ ") {\n");
        next_tab(outfile);
    }
}

static void
do_p1_elseifstart(FILE *outfile)
 //FILE *outfile;
{
    if(*ei_next++) {
        prev_tab(outfile);
        nice_printf(outfile, /*{*/
            "} else /* if(complicated condition) */ {\n" /*}*/);
        next_tab(outfile);
    }
}
